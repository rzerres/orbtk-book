<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The OrbTk Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Orbital Widget Toolkit (OrbTk)is a multi platform toolkit, that enables you to build scalable user interfaces. All components are devoloped with the programming language Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferries.css">
        <link rel="stylesheet" href="theme/2020-edition.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="title-page.html">The Orbtk Widget Toolkit</a></li><li class="chapter-item affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item affix "><li class="part-title">Getting started</li><li class="chapter-item "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item "><a href="ch01-02-hello-orbtk.html"><strong aria-hidden="true">1.2.</strong> Hello OrbTk!</a></li><li class="chapter-item "><a href="ch01-03-ingredients.html"><strong aria-hidden="true">1.3.</strong> The Ingredients</a></li></ol></li><li class="chapter-item "><a href="ch02-00-workspaces.html"><strong aria-hidden="true">2.</strong> OrbTk The Structure</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch02-01-workspace-orbtk.html"><strong aria-hidden="true">2.1.</strong> Workspace: Orbtk</a></li><li class="chapter-item "><a href="ch02-02-workspace-orbtk-core.html"><strong aria-hidden="true">2.2.</strong> Workspace: Orbtk Core</a></li><li class="chapter-item "><a href="ch02-03-workspace-orbtk-client.html"><strong aria-hidden="true">2.3.</strong> Workspace: Orbtk Client</a></li><li class="chapter-item "><a href="ch02-04-workspace-orbtk-tinyskia.html"><strong aria-hidden="true">2.4.</strong> Workspace: Orbtk TinySkia</a></li><li class="chapter-item "><a href="ch02-05-workspace-orbtk-widgets.html"><strong aria-hidden="true">2.5.</strong> Workspace: Orbtk Widgets</a></li><li class="chapter-item "><a href="ch02-06-proc-macros.html"><strong aria-hidden="true">2.6.</strong> Workspace: Process macros</a></li><li class="chapter-item "><a href="ch02-07-utils.html"><strong aria-hidden="true">2.7.</strong> Workspace: Utilities</a></li></ol></li><li class="chapter-item "><a href="ch03-00-widget-templates.html"><strong aria-hidden="true">3.</strong> OrbTk Widget Templates</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch03-01-widget-button.html"><strong aria-hidden="true">3.1.</strong> Template: Button</a></li><li class="chapter-item "><a href="ch03-02-widget-canvas.html"><strong aria-hidden="true">3.2.</strong> Template: Canvas</a></li><li class="chapter-item "><a href="ch03-03-widget-check-box.html"><strong aria-hidden="true">3.3.</strong> Template: CheckBox</a></li><li class="chapter-item "><a href="ch03-04-widget-combo-box.html"><strong aria-hidden="true">3.4.</strong> Template: ComboBox</a></li><li class="chapter-item "><a href="ch03-05-widget-container.html"><strong aria-hidden="true">3.5.</strong> Template: Container</a></li><li class="chapter-item "><a href="ch03-06-widget-cursor.html"><strong aria-hidden="true">3.6.</strong> Template: Cursor</a></li><li class="chapter-item "><a href="ch03-07-widget-font-icon-block.html"><strong aria-hidden="true">3.7.</strong> Template: FontIconBlock</a></li><li class="chapter-item "><a href="ch03-08-widget-grid.html"><strong aria-hidden="true">3.8.</strong> Template: Grid</a></li><li class="chapter-item "><a href="ch03-09-widget-image-widget.html"><strong aria-hidden="true">3.9.</strong> Template: Image-widget</a></li><li class="chapter-item "><a href="ch03-10-widget-list-view.html"><strong aria-hidden="true">3.10.</strong> Template: ListView</a></li><li class="chapter-item "><a href="ch03-11-widget-master-detail.html"><strong aria-hidden="true">3.11.</strong> Template: MasterDetail</a></li><li class="chapter-item "><a href="ch03-12-widget-numeric-box.html"><strong aria-hidden="true">3.12.</strong> Template: NumericBox</a></li><li class="chapter-item "><a href="ch03-13-widget-pager.html"><strong aria-hidden="true">3.13.</strong> Template: Pager</a></li><li class="chapter-item "><a href="ch03-14-widget-password-box.html"><strong aria-hidden="true">3.14.</strong> Template: PasswordBox</a></li><li class="chapter-item "><a href="ch03-15-widget-popup-bar.html"><strong aria-hidden="true">3.15.</strong> Template: Popup</a></li><li class="chapter-item "><a href="ch03-16-widget-progress-bar.html"><strong aria-hidden="true">3.16.</strong> Template: ProgressBar</a></li><li class="chapter-item "><a href="ch03-17-widget-scroll-bar.html"><strong aria-hidden="true">3.17.</strong> Template: ScrollBar</a></li><li class="chapter-item "><a href="ch03-18-widget-scroll-indicator.html"><strong aria-hidden="true">3.18.</strong> Template: ScrollIndicator</a></li><li class="chapter-item "><a href="ch03-19-widget-scroll-viewer.html"><strong aria-hidden="true">3.19.</strong> Template: ScrollViewer</a></li><li class="chapter-item "><a href="ch03-20-widget-slider.html"><strong aria-hidden="true">3.20.</strong> Template: Slider</a></li><li class="chapter-item "><a href="ch03-21-widget-stack.html"><strong aria-hidden="true">3.21.</strong> Template: Stack</a></li><li class="chapter-item "><a href="ch03-22-widget-switch.html"><strong aria-hidden="true">3.22.</strong> Template: Switch</a></li><li class="chapter-item "><a href="ch03-23-widget-tabwidget.html"><strong aria-hidden="true">3.23.</strong> Template: TabWidget</a></li><li class="chapter-item "><a href="ch03-24-widget-textblock.html"><strong aria-hidden="true">3.24.</strong> Template: TextBlock</a></li><li class="chapter-item "><a href="ch03-25-widget-textbox.html"><strong aria-hidden="true">3.25.</strong> Template: TextBox</a></li><li class="chapter-item "><a href="ch03-26-widget-togglebutton.html"><strong aria-hidden="true">3.26.</strong> Template: Togglebutton</a></li><li class="chapter-item "><a href="ch03-27-widget-window.html"><strong aria-hidden="true">3.27.</strong> Template: Window</a></li></ol></li><li class="chapter-item "><a href="ch09-00-orbtk-examples.html"><strong aria-hidden="true">4.</strong> OrbTk Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch09-01-hello-orbtk.html"><strong aria-hidden="true">4.1.</strong> Hello OrbTk!</a></li><li class="chapter-item "><a href="ch09-02-showcase.html"><strong aria-hidden="true">4.2.</strong> Showcase</a></li><li class="chapter-item "><a href="ch09-03-msg-handling.html"><strong aria-hidden="true">4.3.</strong> Message handling</a></li><li class="chapter-item "><a href="ch09-04-popups.html"><strong aria-hidden="true">4.4.</strong> Popups</a></li><li class="chapter-item "><a href="ch09-05-tableview.html"><strong aria-hidden="true">4.5.</strong> Tableview</a></li></ol></li><li class="chapter-item "><a href="appendix-00.html"><strong aria-hidden="true">5.</strong> Appendix</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="appendix-01-keywords.html"><strong aria-hidden="true">5.1.</strong> A - Keywords</a></li><li class="chapter-item "><a href="appendix-02-operators.html"><strong aria-hidden="true">5.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">5.3.</strong> C - Derivable Traits</a></li><li class="chapter-item "><a href="appendix-04-translation.html"><strong aria-hidden="true">5.4.</strong> D - Translations of the Book</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The OrbTk Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/redox-os/orbtk-book/tree/main/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-orbital-widget-toolkit"><a class="header" href="#the-orbital-widget-toolkit">The Orbital Widget Toolkit</a></h1>
<p><a href="img/orbtk_planet.svg"><img src="img/orbtk_planet.svg" width="720"/></a></p>
<p><em>by Florian Blasius, with contributions from the Rust Community</em> <br>
<em>annotated and documented by Ralf Zerres and all contributers</em></p>
<p>This version of the text assumes you’re using OrbTk v0.3.1 or later in
conjuction with Rust v1.41.0 or later. <em>Cargo.toml</em> should define
<code>edition=&quot;2018&quot;</code>. That enables and uses Rust 2018 Edition idioms in
all derived projects.</p>
<p>See the <a href="https://doc.redox-os.org/orbtk-book/ch01-01-installation.html">“Installation” section of Chapter 1</a>
to install or update OrbTk.</p>
<p>The 2020 Edition of this book is the initial release. It will be
released with the OrbTk version 0.3.1.</p>
<ul>
<li>Appendix A “Keywords”, explains the new raw identifiers.</li>
<li>Appendix D “Translations”, is work in progress. We will release
instances of this book in the target language once they are translated.</li>
</ul>
<p>For online reading, a HTML rendered version is available at <a href="https://www.redox-os.org/orbtk-book/book-en/doc/book-en">Orbtk
book_en</a>. Alternatively you might want to have it handy
for offline usage. Either you downlaod a rendered <code>pdf</code> or
<code>ebook</code>version or go ahead and download the source. Then kick on
mdbook (the definition of the target location is optional).</p>
<pre><code class="language-console">mdbook build --dest-dir doc/book_en --open
</code></pre>
<!---
This text is available in [paperback and ebook format from No Starch Press][nsprust].
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p>This book fully embraces the potential of Rust for develpers creating modern,
fast and extendable user interfaces. Since all component of OrbTk are coded
in Rust itself, it inherits all the benefits of this extraorenary programming
infrastructure. The minimalistic resource consumption, memory safety and a
condensed, well structured modular source code are key factors that makes
OrbTk a promising basis for your future multiplatform GUI projects.</p>
<p>Back in the 80’th runtime environments like Java pioniered the idea of a
“programming once, run everywhere” toolchain. Rust in combination with
OrbTk offers the opportunity to fullfill this goal while providing
speed, safety and multithreading. You are free to lavarage the capabilities
of modern hardware: Take advantage of multicore CPUs in microcomputers,
single board computers or the diversity of cloud infrastructures.
Rust let you compile native binary-code and OrbTk will offer the needed
crates, to produce software that matches user demands: running fast,
secure and reliable applications.</p>
<p>Its users will enjoy the friendly and approachable text, that is intended to
help you level up not just your knowledge towards GUI development, but will
also improve your understanding of Rust code. Dive in, get ready to be a
member of the OrbTk and Rust community!</p>
<p>— Ralf Zerres</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<!--
> WIP: to be uncommented, once it is done
> Note: This edition of the book is the same as
> [The Orbital Widget Toolkit][nsporbtk] available in print
> and ebook format from [No Starch Press][nsporbtk].

[nsporbtk]: https://nostarch.com/orbtk
[nsp]: https://nostarch.com/
-->
<p><a href="img/orbtk.svg"><img src="img/orbtk.svg" width="720"/></a></p>
<p>Welcome to <em>The Orbital Widget Toolkit</em>, an introductory book about <code>OrbTk</code>.
The Rust programming language helps you write faster and reliable software.
<code>OrbTk</code> contribute the needed crates, to develop modern graphical user interfaces.
It offers a single code base that compiles to native binary code that is executed
on your target platform.</p>
<div class="warning">
<p>Warning: This book is incomplete.  Documenting everything and
rewriting outdated parts take a while.
See the <a href="https://github.com/redox-os/orbtk-book/issues">issue tracker</a> to check what’s missing or outdated. If there
are any mistakes or ideas that haven’t been reported, feel free to
open a new issue there.</p>
</div>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li>Modern lightweight API</li>
<li>Cross platform</li>
<li>Modular crates</li>
<li>Based on Entity Component System library DCES</li>
<li>Flexible event system</li>
<li>Integrated widget library</li>
<li>Custom widgets</li>
<li>Custom theming engine</li>
<li>Dynamic theme switching</li>
<li>Integrated debugging tools</li>
<li>Localization</li>
</ul>
<h2 id="supported-platforms"><a class="header" href="#supported-platforms">Supported Platforms</a></h2>
<ul>
<li>Redox OS (native)</li>
<li>Linux (native | cargo-node)</li>
<li>macOS (native | cargo-node)</li>
<li>Windows (native | cargo-node)</li>
<li>openBSD (not tested, but should work)</li>
<li>Web (cargo-node)</li>
<li>Android (native planned | cargo-node)</li>
<li>iOS (native planned | cargo-node planned)</li>
<li>Ubuntu Touch (native planned | cargo-node planned)</li>
</ul>
<h2 id="who-orbtk-is-for"><a class="header" href="#who-orbtk-is-for">Who OrbTk Is For</a></h2>
<p><code>OrbTk</code> is ideal for programmers that like to take advantage of the Rust programming
language. No need to transform data structures and types: OrbTk itself is coded in
Rust. It naturally adopts all the structural advantages and provides the needed GUI
elements to code your application. Let’s look at a few of
the most important groups.</p>
<h3 id="teams-of-developers"><a class="header" href="#teams-of-developers">Teams of Developers</a></h3>
<p>Rust is proving to be a productive tool for collaborating among large teams of
developers with varying levels of systems programming knowledge. Have a look at
the Rust book that elaborates the fundamental principles that enables you to
produce more secure code.</p>
<p><code>OrbTk</code> reuses the Rust toolchain as much as possible. Contemporary developer
that have passed the learning curve will take advantage of:</p>
<ul>
<li>Cargo, the included dependency manager and build tool, makes adding,
compiling, and managing dependencies painless and consistent across the Rust
ecosystem.</li>
<li>Rustfmt ensures a consistent coding style across developers.</li>
<li>The Rust Language Server powers Integrated Development Environment (IDE)
integration for code completion and inline error messages.</li>
</ul>
<h3 id="students"><a class="header" href="#students">Students</a></h3>
<p>Rust is for students and those who are interested in learning about systems
concepts. Using Rust, many people have learned about topics like operating
systems development. The community is very welcoming and happy to answer
student questions. Through efforts such as this book, the Rust teams want to
make systems concepts more accessible to more people, especially those new to
programming.</p>
<h3 id="companies"><a class="header" href="#companies">Companies</a></h3>
<p>Hundreds of companies, large and small, use Rust in production for a variety of
tasks. Those tasks include command line tools, web services, DevOps tooling,
embedded devices, audio and video analysis and transcoding, cryptocurrencies,
bioinformatics, search engines, Internet of Things applications, machine
learning, and even major parts of the Firefox web browser.</p>
<h3 id="open-source-developers"><a class="header" href="#open-source-developers">Open Source Developers</a></h3>
<p><code>OrbTk</code> is for people who want to build with the Rust programming language,
its community, its developer tools, and libraries. We’d love to have you
contribute to its crates and entities.</p>
<h2 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who This Book Is For</a></h2>
<p>This book assumes that you’ve written code in another programming language
and other GUI toolkits. We do not make any assumptions about which specific
one. We’ve tried to make the material broadly accessible to those from a
wide variety of development backgrounds. We don’t spend a lot of time
talking about what programming <em>is</em> or how to think about it.
If you’re entirely new to programming, you would be better served by
reading a book that specifically provides an introduction to programming.</p>
<h2 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to Use This Book</a></h2>
<p>In general, this book assumes that you’re reading it in sequence from front to
back. Later chapters build on concepts in earlier chapters, and earlier
chapters might not delve into details on a topic; we typically revisit the
topic in a later chapter.</p>
<p>You’ll find two kinds of chapters in this book: concept chapters and project
chapters. In concept chapters, you’ll learn about an aspect of <code>OrbTk</code>. In project
chapters, we’ll build small programs together, applying what you’ve learned so
far.</p>
<p>Chapter 1 explains how to install Rust and OrbTk, how to write a minimal program,
and how to use Cargo, Rust’s package manager and build tool.</p>
<p>Finally, some appendixes contain useful information about the  in a
more reference-like format. Appendix A covers OrbTk’s keywords, Appendix B
covers OrbTk’s derivable traits and crates.</p>
<p>There is no wrong way to read this book: if you want to skip ahead, go for it!
You might have to jump back to earlier chapters if you experience any
confusion. But do whatever works for you.</p>
<p><span id="ferris"></span></p>
<p>An important part of the process of learning <code>OrbTk</code> is learning how to read the
error messages the compiler displays: these will guide you toward working code.
As such, we’ll provide many examples that don’t compile along with the error
message the compiler will show you in each situation. Know that if you enter
and run a random example, it may not compile! Make sure you read the
surrounding text to see whether the example you’re trying to run is meant to
error. Ferris will also help you distinguish code that isn’t meant to work:</p>
<table><thead><tr><th>Ferris</th><th>Meaning</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain"/></td><td>This code does not compile!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain"/></td><td>This code panics!</td></tr>
<tr><td><img src="img/ferris/unsafe.svg" class="ferris-explain"/></td><td>This code block contains unsafe code.</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/></td><td>This code does not produce the desired behavior.</td></tr>
</tbody></table>
<p>In most situations, we’ll lead you to the correct version of any code that
doesn’t compile.</p>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>The source files from which this book is generated can be found on
the Homepage at <a href="https://github.com/redox-os/orbtk-book/tree/master/src/en">Orbtk book (en)</a>.</p>
<!---
[book]: https://github.com/redox-os/orbtk-book
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Let’s start your OrbTk journey! There’s a lot to learn, but every journey starts
somewhere. In this chapter, we’ll discuss:</p>
<ul>
<li>Installing OrbTk on Linux, Bsd, macOS, and Windows.</li>
<li>Writing a basic OrtTK application that opens a windows placing
<code>Hello OrbTk!</code> in its center.</li>
<li>Using <code>cargo</code>, Rust’s package manager and build system.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>The first step is to install Rust. This is described in depth following
<a href="https://github.com/rust-lang/book/blob/master/src/ch01-01-installation.md">Rust book Chapter 1</a></p>
<p>When creating a OrbTk application, we define the needed dependencies to the
OrbTk crates in the Cargo.toml file of our project. The complile process
will resolve the references and download the source as needed.</p>
<blockquote>
<h3 id="command-line-notation"><a class="header" href="#command-line-notation">Command Line Notation</a></h3>
<p>In this chapter and throughout the book, we’ll show some commands used in the
terminal. Lines that you should enter in a terminal all start with <code>$</code>. You
don’t need to type in the <code>$</code> character; it indicates the start of each
command. Lines that don’t start with <code>$</code> typically show the output of the
previous command. Additionally, PowerShell-specific examples will use <code>&gt;</code>
rather than <code>$</code>.</p>
</blockquote>
<h3 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h3>
<blockquote>
<p><em><strong>WIP</strong></em>:  What are the most common culprits? Can we provide some general, basic solutions</p>
</blockquote>
<h3 id="local-documentation"><a class="header" href="#local-documentation">Local Documentation</a></h3>
<p>OrbTk offers the option to install its documentation locally, so you can read it
offline.</p>
<p>Any time a type, a function, a method or a crate is reference by the toolkit
and you’re not sure what it does or how to use it, have a look at its application
programming interface <a href="https://docs.rs/orbtk">API documentation</a> to find out!</p>
<!-- [API documentation]: https://www.redox-os.org/orbtk/doc/en -->
<!-- [API documentation]: https://github.com/redox-os/orbtk -->
<h3 id="install-rust-on-linux-or-macos"><a class="header" href="#install-rust-on-linux-or-macos">Install Rust on Linux or macOS</a></h3>
<p>If you are using Linux or macOS open up an terminal and copy and paste the text below and hit the enter key on your keyboard:</p>
<pre><code class="language-bash">curl https://sh.rustup.rs -sSf | sh
</code></pre>
<h3 id="install-rust-on-windows"><a class="header" href="#install-rust-on-windows">Install Rust on Windows</a></h3>
<p>Download and run the Rust windows installer from https://www.rust-lang.org/tools/install.</p>
<h3 id="install-redoxer-redox-os"><a class="header" href="#install-redoxer-redox-os">Install Redoxer (Redox OS)</a></h3>
<p>If you want build and run your Rust application on a <a href="https://en.wikipedia.org/wiki/Kernel-based_Virtual_Machine">KVM</a> capable OS for Redox you can use <a href="https://gitlab.redox-os.org/redox-os/redoxer">redoxer</a>.</p>
<p>To install Redoxer you have to first install the rust toolchain. After that open up an terminal and copy and paste the text below and hit the enter key on your keyboard:</p>
<pre><code class="language-bash">cargo +nightly install redoxer
</code></pre>
<p>To compile and run your application on Redox OS you should check the Redox OS Book.</p>
<h3 id="editor-and-ide-integration"><a class="header" href="#editor-and-ide-integration">Editor and IDE integration</a></h3>
<p>A wide range of editors and IDE’s are providing support for Rust code like</p>
<ul>
<li>like syntax-highlighting</li>
<li>auto-completion</li>
<li>linting</li>
<li>lsp support</li>
</ul>
<h4 id="vs-code"><a class="header" href="#vs-code">VS Code</a></h4>
<p>There is a big community that rely on the visualstudio implementation
to handle their code base. Following are the steps needed to expand
your installation to support <code>VS Code for Rust</code> development:</p>
<ol>
<li>Download VS Code <a href="https://code.visualstudio.com/download">from</a>.</li>
<li>Install <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">Rust Language Server plugin</a> (the
Rust Language Server).</li>
</ol>
<h4 id="alternative-editors-and-ides"><a class="header" href="#alternative-editors-and-ides">Alternative Editors and IDEs</a></h4>
<p>If you perefer other solution, you will find in depth help inside the
context of this inclomplete links:</p>
<ul>
<li><a href="https://atom.io/packages/language-rust">Atom</a></li>
<li><a href="https://intellij-rust.github.io">Intellij IDEA</a></li>
<li><a href="https://github.com/rust-lang/rust.vim">Vim</a></li>
<li><a href="https://github.com/rust-lang/rust-mode">Emacs</a></li>
<li><a href="https://github.com/eclipse/corrosion">Eclipse</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hello-orbtk"><a class="header" href="#hello-orbtk">Hello OrbTk!</a></h2>
<p><a href="img/orbtk.svg"><img src="img/orbtk.svg" width="720"/></a></p>
<p>Now that you’ve installed the needed building blocks, let’s write your first
OrbTk program. It’s traditional when learning a new language to write a little
program that outputs the text <code>Hello, world!</code>. So we’ll do the same here. We
create a minimal app, that creates a window, position this window at the given
coordinate of your screen. The text will be placed  in the center of this
widget.</p>
<blockquote>
<p>Note: This book assumes basic familiarity with the command line. Rust makes
no specific demands about your editing or tooling or where your code lives, so
if you prefer to use an integrated development environment (IDE) instead of
the command line, feel free to use your favorite IDE. Many IDEs now have some
degree of Rust support; check the IDEs documentation for details. Recently,
the Rust team has been focusing on enabling great IDE support, and progress
has been made rapidly on that front!</p>
</blockquote>
<h3 id="creating-a-project-directory"><a class="header" href="#creating-a-project-directory">Creating a Project Directory</a></h3>
<p>You’ll start by making a directory to store your OrbTk code. It doesn’t matter
to Rust and OrbTk where your code lives, but for the exercises and projects in
this book, we suggest making a <em>projects</em> directory in your home directory and
keeping all your projects there.</p>
<p>Open a terminal and enter the following commands to make up the <em>projects</em> structure.</p>
<p>For Linux, BSD, macOS, and Power-Shell on Windows:</p>
<pre><code class="language-console">$ mkdir -p ~/orbtk-book/projects
$ cd ~/orbtk/projects
</code></pre>
<p>For Windows CMD:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\orbtk-book&quot;
&gt; cd /d &quot;%USERPROFILE%\orbtk-book&quot;
&gt; mkdir projects
&gt; cd projects
</code></pre>
<h3 id="writing-and-running-a-orbtk-application"><a class="header" href="#writing-and-running-a-orbtk-application">Writing and Running a OrbTk Application</a></h3>
<p>Next, we make a new project using <em>Cargo</em>. With its <em>.toml</em> file we
allow Rust to declare the various dependencies and metadata. That
ensures that you’ll always get a repeatable output of the build.</p>
<p>Go ahead like so:</p>
<pre><code class="language-console">$ cargo new orbtk_hello
$ cd orbtk_hello
</code></pre>
<p>The first command, <code>cargo new</code>, takes the name of the project
(“<code>orbtk_hello</code>”) as the first argument. The second command changes to
the new project’s directory.</p>
<p>Look at the generated <em>Cargo.toml</em> file:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;orbtk_hello_example&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p><span class="caption">Listing 1-1: Default metadata “orbtk_hello”</span></p>
<p>With <code>cargo new</code>, a default project structure is created. Maybe the
author information is already exchanged if <em>Cargo</em> could obtain a definition
from your environment. <em>Cargo</em> also generated source code for a “Hello, world!”
program. Let’s Check out the corresponding <em>src/main.rs</em> file:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 1-2: Default source file “main.rs”</span></p>
<p>No need to compile that stage with <code>cargo run</code>, since we are going to
exchange the project metadata, as well as the orbtk source code right
away.</p>
<h4 id="update-cargotoml"><a class="header" href="#update-cargotoml">Update Cargo.toml</a></h4>
<p>First reopen the <em>Cargo.toml</em> file and enter the Code in Listing 1-1 into <em>Cargo.toml</em></p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml ignore">[package]
name = &quot;orbtk_hello&quot;
version = &quot;0.3.1-alpha4&quot;
authors = [
	&quot;Florian Blasius &lt;flovanpt@posteo.de&gt;&quot;,
	&quot;Ralf Zerres &lt;ralf.zerres.de@gmail.com&gt;&quot;,
]
description = &quot;The Orbital Widget Toolkit - Training project&quot;
documentation = &quot;https://docs.rs/orbtk&quot;
repository = &quot;https://github.com/redox-os/orbtk&quot;
readme = &quot;README.md&quot;
license = &quot;MIT&quot;
keywords = [
	&quot;orbital&quot;,
	&quot;widget&quot;,
	&quot;ui&quot;,
]
edition = &quot;2018&quot;

[profile.dev]
opt-level = 1

[dependencies]
orbtk = { git = &quot;https://github.com/redox-os/orbtk.git&quot;, branch = &quot;develop&quot; }
#orbtk = { path = &quot;../../../orbtk&quot;, branch=&quot;next&quot; }

[[bin]]
name = &quot;orbtk_hello&quot;
path = &quot;src/main.rs&quot;
</code></pre>
<p><span class="caption">Listing 1-1: Project metadata “orbtk_hello”</span></p>
<p>You may wonder, why the <em>name</em> property inside the <em>Cargo.toml</em> is
formatted like <code>hello_orbtk</code>.</p>
<pre><code class="language-toml ignore">name = &quot;orbtk_hello&quot;
</code></pre>
<p>It is a good habit to follow rusts
naming convention, that encourages you to use <a href="https://rust-lang.github.io/api-guidelines/naming.html">snake_case</a>
naming. While expanding the <em>OrbTk</em> example sources, we will keep
the grouping prefix <code>orbtk</code>. That way we end up to call our first target
binary <code>orbtk_hello</code>.</p>
<h4 id="update-mainrs"><a class="header" href="#update-mainrs">Update main.rs</a></h4>
<p>All of the <em>OrbTk</em> specific code that is needed to build our first
example “Hello OrbTk!” is shown in Listing 1-2. It goes to
<em>src/main.rs</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use orbtk::prelude::*;

fn main() {
    // use this only if you want to run it as web application.
    orbtk::initialize();

    Application::new()
        .window(|ctx| {
            Window::new()
                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
                .position((100.0, 100.0))
                .size(420.0, 140.0)
                .child(
                    TextBlock::new()
                        .font_size(28)
                        .h_align(&quot;center&quot;)
                        .text(&quot;Hey OrbTk!&quot;)
                        .v_align(&quot;center&quot;)
                        .build(ctx)
                )
                .build(ctx)
        })
        .run();
}
</code></pre>
<p><span class="caption">Listing 1-2: Code that creates a Window and
prints “Hey OrbTk!”</span></p>
<p>Save the file and go back to your terminal window. Enter the following
commands to compile and run the file:</p>
<pre><code class="language-console">$ cargo run --release orbtk_hello
</code></pre>
<blockquote>
<p><em><strong>Note</strong></em>: Perhaps the OS requires you to install the development version
of SDL2 via the distribution package-manager (e.g. for Ubuntu: libsdl2-dev).</p>
</blockquote>
<p>Regardless of your operating system, a window should be placed on the screen
that prints the string <code>Hey OrbTk!</code> in its center.</p>
<p><a href="img/examples/orbtk_hello.png"><img src="img/examples/orbtk_hello.png" height="150"/></a></p>
<p><span class="caption">Image 1-2: Application window and <code>Hey OrbTk</code></span></p>
<p>If something is preventing to position the window, refer back to the
<a href="https://doc.redox-os.org/orbtk-book/ch01-01-installation.html#troubleshooting">“Troubleshooting”</a> part of the Installation section for
ways to get help.</p>
<p>If your enjoy the rendered output of your <code>Hey OrbTk!</code> app,
congratulations! You’ve written your first OrbTk application.
That makes you a OrbTk programmer — welcome!</p>
<h3 id="anatomy-of-an-orbtk-application"><a class="header" href="#anatomy-of-an-orbtk-application">Anatomy of an OrbTk Application</a></h3>
<p>Let’s have a closer look at the code structure of this first “Hey
OrbTk!”  application.</p>
<p>For now it should be sufficient to disenchant the first puzzle pieces.
If you like to understand the structure in a more generic way, in <a href="https://doc.redox-os.org/orbtk-book/ch02-05-workspace-orbtk-widgets.html">Chapter
Workspace</a> we are going to provide the details.</p>
<pre><code class="language-rust ignore">use orbtk::prelude::*;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<p>The first line is introducing a <em>use</em> declaration. A <em>use</em> declaration is used
to shorten the path required to refer to rust module items. The <em>prelude</em> is a
convenient way to a list of things, that rust will automatically import to you
program. Here, we bind the path <em>orbtk::prelude</em>. All default items defined in
this path (referenced with <em>::</em>) are now accessible in your source using their
shorthand name. No need to type in their common prefix (<em>orbtk::prelude::</em>)</p>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span>fn main() {
<span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<p>the third line define a function in Rust. The <code>main</code> function is special: it is
always the first code that runs in every executable Rust program. The first
line declares a function named <code>main</code> that has no parameters and returns
nothing. If there were parameters, they would go inside the parentheses, <code>()</code>.</p>
<p>Also, note that the function body is wrapped in curly brackets, <code>{}</code>. Rust
requires these around all function bodies. It’s good style to place the opening
curly bracket on the same line as the function declaration, adding one space in
between.</p>
<p>An automatic formatter tool called <code>rustfmt</code> will help you to stick to a
standard style across Rust projects. OrbTk is following this guidance.
<code>rustfmt</code> will format your code in a particular style. Depending on the version
of your rust toolchain, it is probably already installed on your computer!
Check the online documentation for more details.</p>
<p>Inside the <code>main</code> function is the following code:</p>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // use this only if you want to run it as web application.
    orbtk::initialize();
<span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<p>Here are some important details to notice.</p>
<ul>
<li>First, Rust style is to indent with four spaces, not a tab.</li>
<li>Second, the method <code>orbkt::initialize</code> does all the hard work to initialize
the orbtk environment.</li>
</ul>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span>    Application::new()
<span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<ul>
<li>Third, the method <code>Application::new</code> creates a new entity in the entity
component system (DECS). DECS is an OrbTk dependency that will create and
organize all OrbTk entities. If OrbTk methods change attributes to the widget
elements, the corresponding DECS object will store this attributes as
components to the given entity.</li>
</ul>
<p>We’ll discuss OrbTk macros and methods in more detail in Chapter &lt;WIP: chapter&gt;.
For now, you just need to know that using a <code>::new()</code> means that you’re calling
the creation method of a given widget (here: <code>Application</code>).</p>
<p>Let’s explain the next lines:</p>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span>        .window(|ctx| {
            Window::new()
                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
                .position((100.0, 100.0))
                .size(420.0, 140.0)
<span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<p>Inside the <code>Application</code> method, we pipe in further instructions. Please notice
the important details:</p>
<ul>
<li>First, Rust style is to indent with another four spaces, not a tab.</li>
<li>Second, The piping is encoded using a <code>dot</code> followed by a new method name
(here <code>window</code>).</li>
<li>Third, the <code>windows</code> method takes a Rust closure as its argument.</li>
</ul>
<p>If you are not familiar with the concept of
<a href="https://doc.rust-lang.org/rust-by-example/fn/closures.html">closures</a>,
go ahead and consult the Rust book reference for a deep dive. For now,
you just need to know that a closure can be used as a language
shortcut for a function.  When the closure <code>|ctx| {}</code> is executed, the
result will be captured inside a return variable (<code>ctx</code>). The curly
braces define the body, with the code that is executed inside the
closure.</p>
<p>Let’s examine this body code of our closure:</p>
<ul>
<li>First, we call a method to create a new window entity.
(<code>Windows::new</code>).</li>
<li>Second, we define attributes attached to this entity (<code>title</code>,
<code>position</code>, <code>size</code>).</li>
<li>Third, inside the defined windows, we create a new child entity
(<code>child</code>).</li>
</ul>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span>                .child(
                    TextBlock::new()
                        .font_size(28)
                        .h_align(&quot;center&quot;)
                        .text(&quot;Hey OrbTk!&quot;)
                        .v_align(&quot;center&quot;)
                        .build(ctx)
                )
<span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<ul>
<li>Forth, the child method takes arguments. We create a new text block
entity (<code>Textblock::new</code>). The text block is extended with the attributes
(<code>text</code>, <code>h_align</code>, <code>v_align</code>).
The text attribute takes the desired string. Its positioning is
controlled with the attribution of the horizontal and vertical
alignment. By choosing “center”, we do advise the renderer to place
the entity centered within its parent entity, which is the window.</li>
</ul>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span>                .build(ctx)
<span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<p>OrbTk is as lazy as possible. We need to call the build method (<code>build(ctx)</code>),
that will instantiate our methods and let the renderer do its work.</p>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span>        .run();
<span class="boring">}
</span></code></pre>
<p>With the last statement, we finally call the method that will activate the
Application and draw the Widget on our screen (<code>run</code>).</p>
<p>Most lines of Rust code are finalized with a semicolon (<code>;</code>), to indicates that this
expression is finished and the next one is ready to begin.</p>
<h3 id="compiling-and-running-are-separate-steps"><a class="header" href="#compiling-and-running-are-separate-steps">Compiling and Running Are Separate Steps</a></h3>
<p>Before running an OrbTk application, you must compile its source code. A typical
OrbTk project will generate the executable binary code using cargo and place the
result in the target subfolder of the project.</p>
<p>Profiles may be used to configure compiler options such as optimization levels
and debug settings. By default the <code>dev</code> or <code>test</code> profiles are used. If the
<code>--release</code> flag is given, then the release or bench profiles are used.</p>
<pre><code class="language-console">$ cargo build --release --bin orbtk_hello.rs
$ ../target/release/hello_orbtk
</code></pre>
<p>On Windows, you need to use <code>backslash</code> as a path delimiter:</p>
<pre><code class="language-powershell">&gt; cargo build --release --bin orbtk-hello.rs
&gt; ..\target\release\orbtk_hello.exe
</code></pre>
<p>If you like to get debug feedback you can call the build process like this</p>
<pre><code class="language-console">$ cargo build --features debug --bin hello_orbtk.rs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-ingredients"><a class="header" href="#the-ingredients">The Ingredients</a></h1>
<p><code>OrbTk</code> provides an <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">interactive functional
reactive</a> API. It depends on the rust
<a href="https://docs.rs/dces"><code>DCES</code></a> crate, that provides an Entity Component
System. Interaction with <code>DCES</code> is managed via the <code>Entity Component Manager</code>(ECM), a wrapper API, that transparently maps <code>OrbTk</code> widgets
to <code>ECM</code> entities and <code>OrbTk</code> properties to <code>ECM</code> components.</p>
<h2 id="the-widget-view"><a class="header" href="#the-widget-view">The widget view</a></h2>
<pre class="mermaid">graph TD;
	View--&gt;Widget-Container_1;
	View--&gt;Widget-Container_2;
	Widget-Container_1--&gt;Child-Widget1_1;
	Widget-Container_1--&gt;Child-Widget1_2;
	Widget-Container_1--&gt;Child-Widget1_n;
	Widget-Container_2--&gt;Child-Widget2_1;
	Widget-Container_2--&gt;Child-Widget2_2;
	Widget-Container_2--&gt;Child-Widget2_n;
</pre>
<p><span class="caption">Workflow 1-1: View handling methods</span></p>
<p>When you construct an OrbTk application, you are essentially combining
<code>widgets</code>. Widgets are the building blocks of user interfaces in
OrbTk, dedicated to a given task. The given model is dynamically
structured. You are free to implement your own widget type or consume
the predefined implementations.</p>
<p>To make up a <code>widget-tree</code>, you may construct a <code>ListView</code>, that
instantiates a child <code>TextBox</code> that itself instantiates a child
<code>Button</code>. You end up with an ordered user interface (the <code>view</code>), the
visible part of your app. Each widget-tree is stacked into a uniquely
addressable <code>widget-container</code>.</p>
<h3 id="widget-trait"><a class="header" href="#widget-trait">Widget trait</a></h3>
<p>Each widget need to implement the Widget trait. It is generated by the
<code>widget!()</code> macro.</p>
<p>A widget consists of a name (eg. <code>Button</code>) that is bound to a list of
properties (eg. <code>text: String</code>, <code>background: Brush</code> or <code>count: u32</code>). When the <code>build()</code> method of a widget is called inside the
widget-tree, that widget is added to the Entity Component System with
a unique <code>Entity</code> (index) that holds corresponding <code>Components</code> (property
names). The struct of the widget-container serves as its builder pattern.</p>
<h3 id="widget-template"><a class="header" href="#widget-template">Widget Template</a></h3>
<p>Each widget has to implement the <code>Template</code> trait. The template defines
the default values of all assigned widget’s properties as well as its
structure. E.g. a Button consists of a Container widget, a StackPanel
widget and a TextBox widget.</p>
<p>Separating the <code>view</code> as the descriptive nature of a widget tree from
the code that reacts and handles user input (it’s <code>state</code>), is an
essential conceptual decision. It is key to enable the fast, flexible
and extendable structure of OrbTk.</p>
<h2 id="the-widget-state"><a class="header" href="#the-widget-state">The widget state</a></h2>
<pre class="mermaid">graph TD;
	State--&gt;init;
	State--&gt;update;
	State--&gt;cleanup;
	update--&gt;message;
	message--&gt;layout;
	layout--&gt;update_post_layout;

</pre>
<p><span class="caption">Workflow 1-2: State handling methods</span></p>
<p>Widgets make use of traits, that come in handy to provide
interactivity. We call them the widget <code>state</code>. Inside the <code>state</code>
routines, we declare the processing and controlling code dedicated to
a given task.</p>
<p>It is <strong>not</strong> required to define a <code>state</code> for a widget. But if you
don’t, you cut of the possibility to adapt properties during
runtime. The <code>view</code> of the widget will stay static.</p>
<p>When defining a <code>state</code> of a widget, it inherits the values of its
associated properties (<code>current values</code>), as well as the implemented
system. To gain access, each state has to derive or implement the
<code>Default</code> and the <code>AsAny</code> traits. You are free to implement
associated functions to the <code>state</code>, that react on triggered events or
adapt current values. The <code>properties</code> are stored via ECM. They are
organized in a tree (parent, children or level entities).</p>
<h2 id="gui-elements"><a class="header" href="#gui-elements">GUI Elements</a></h2>
<ul>
<li>Layouts</li>
<li>Events</li>
<li>Behaviors</li>
<li>Messages</li>
</ul>
<h3 id="layouts"><a class="header" href="#layouts">Layouts</a></h3>
<p>Layouts are addressing the problem, that each widget inside the UI
needs individual placement. This requires a dynamic calculation of its
space requirements coupled with is target specific positioning when
interacting with the display device.</p>
<h4 id="why-do-we-need-layouts"><a class="header" href="#why-do-we-need-layouts">Why do we need layouts?</a></h4>
<p>Well, lets take an obvious example that meets every modern
application: You have to support multiple language variants! Changing
the selected localization should be possible at runtime. We do expect,
that each needed idiom inside our application will for sure differ in
their label length, as well as the sizes of used glyphs in the
selected fonts. What would happen, if we would size the entities
statically? We would code e.g a button with a given size. How to react
on content changes of its child entity (e.g. a label that is expected
to be centered inside the button frame)?</p>
<p>Pugh, you as the programmer would need to adapt the GUI views for every
supported language and react on pragmatically on any of this size
changes. A nightmare! This is nonsense. We have to define and render
the stuff the other way around!</p>
<h4 id="our-solution"><a class="header" href="#our-solution">Our solution</a></h4>
<p><code>OrbTk</code> uses a <code>layout</code> system. This system support the ability to
determine the natural size of the content elements. It allows a dynamic
approach to layout all entities inside the toolkit. No matter if the
application logic requires to add or subdivide other entities inside
the widget tree. Or if contents is changed through theme adaption or
user interaction: all involved entities are processed and resized as
needed, respecting their individual constraints.</p>
<p>Constraints are defined via entity properties that are
stored as components inside the <code>DCES</code>. The concept follows a two
phase model. It will process the entity tree in two passes:</p>
<ul>
<li><code>Measuring</code> pass</li>
<li><code>Arrangement</code> pass</li>
</ul>
<p>This is the reason, we call it a <code>functional_reactive</code> Toolkit.</p>
<h4 id="measuring"><a class="header" href="#measuring">Measuring</a></h4>
<p>The <code>Measuring</code> pass allows us to determine the <strong>desired size</strong> of a
<code>boxed</code> entity. A desired size is a structure, that holds the maximum
values for the width and height of the entity in question. This values
are stored inside <code>DCES</code>. If computation recognizes a size change of
the <code>desired size</code>, which means the stored and the current value of
its property differs, the <code>dirty flag</code> is set. The measuring will
result in an update of the associated bound values inside the <code>DECS</code>
entity (structure <strong>desired size</strong>).</p>
<h4 id="arrangement"><a class="header" href="#arrangement">Arrangement</a></h4>
<p>The <code>Arrangement</code> is following in a separate run. It will trigger the
2D rendering task. This task walks down the element tree and consume
the <strong>bounds</strong> of each entry. A <code>bound</code> describes the finalized
alignment position of an entity (height, width) and is stored inside
the <code>DCES</code>. Computation tasks are only triggered, if the values of
a tree element have changed, which will be indicated via the <code>dirty</code>
flag. All referenced elements that are affected by this changed values
need to be rearranged. Their positions are recomputed with the
appropriate values inside the render buffer, since the active state
was marked dirty.</p>
<p>After the arrangement pass, the dirty flag is cleaned, which will omit
any further computational needs. Once the state of an entity is marked
as dirty again, the pass runs are triggered as desired.</p>
<h4 id="layout-methods"><a class="header" href="#layout-methods">Layout Methods</a></h4>
<p><code>OrbTk</code> supports a number of dedicated layout methods, that are
designed to handle the specific demands of a given widget type:</p>
<ul>
<li>Absolute</li>
<li>Fixed size</li>
<li>Grid</li>
<li>Padding</li>
<li>Popup</li>
<li>Stack</li>
</ul>
<p>You can find the relevant code inside the <code>orbtk_core</code> workspace. The methods are inside the sub-directory <code>layout</code>.
Further information towards this methods are discussed in <a href="https://doc.redox-os.org/orbtk-book/ch02-02-workspace-orbtk-core.html#layout">Chapter: Orbtk_core</a>.</p>
<h3 id="events"><a class="header" href="#events">Events</a></h3>
<ul>
<li>bottom-up</li>
</ul>
<p>If the events traverse from a leaf entity up to the root entity.</p>
<ul>
<li>top-down</li>
</ul>
<p>If the events traverse from the root entity down to the leaf entities.</p>
<h3 id="behaviours"><a class="header" href="#behaviours">Behaviours</a></h3>
<p>Specialized event handling methods are available to reacts on signals.
These currently include the event classes</p>
<ul>
<li>Mouse behaviors</li>
<li>Selection behaviors</li>
<li>Text behaviors</li>
</ul>
<p>Signals may be fired from ether input devices
(e.g. mouse, keyboard) or inside the functional logic (e.g. changing focus, text, etc).</p>
<h3 id="messages"><a class="header" href="#messages">Messages</a></h3>
<p>An intelligent messaging infrastructure that instantiates subs. The
concept enables the toolkit to send and receive messages between the
linked entities (m senders -&gt; n receivers). The implemented methods are <code>thread save</code>.</p>
<p>Each widget may implement a <code>message</code> Method in its state code. The
devoloper is free which method adapters he/she likes to incorpoerate
and how to process the encountered messages.</p>
<h2 id="framework-elements"><a class="header" href="#framework-elements">Framework Elements</a></h2>
<p>The elements are organised as sub-modules inside the API sub-tree.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-workspace-structure"><a class="header" href="#orbtk-workspace-structure">OrbTk workspace structure</a></h1>
<p>While developing OrbTk, we try to take care of some basic principles</p>
<ul>
<li>modularity</li>
<li>extensibility</li>
<li>multiplatfom awareness</li>
</ul>
<p>Within the Rust ecosystem, <code>workspaces</code> are a natural way to distinct
code blocks, that define a logical entity. That allow you to split one
big crate into multiple smaller ones. Beside the ordering factor this
code-splitting is great for avoiding repetitive compilation of the
code, because only crates with changes have to be recompiled. The
result may reduce the compile time by an order of magnitude. Obviously
<code>OrbTk</code> is using such a structure.</p>
<p>We do provide to following workspaces:</p>
<ul>
<li>orbtk</li>
<li>orbtk_core</li>
<li>orbtk_orbclient</li>
<li>orbtk_tinyskia</li>
<li>orbtk_widgets</li>
<li>proc_macros</li>
<li>utils</li>
</ul>
<p>The components and relations within the code base will be discussed
step by step in the following chapters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-orbtk"><a class="header" href="#workspace-orbtk">Workspace OrbTk</a></h1>
<p>This workspace is the entry point into the framework code.
If you are familiar with Rust code, we are following best practice.</p>
<p>Lets have a quick look at the <code>src</code> sub-directory. As usual you will
find a <code>lib.rs</code> source file.</p>
<p>Obviously here the code starts to define the crates type “lib”. The
next lines define an <code>outer documentation block</code>, which serves as a
short introduction. <code>Outer documentation</code> lines are encoded with two
slashes followed by an exclamation mark (<code>//!</code>).</p>
<p>A very strong feature of the Rust toolchain is the availability of an
inline documentation subsystem. We do use this feature extensively
within <code>OrbTk</code>, to document every public accessible code module,
public functions, structure or enumeration. <code>Inner documentation blocks</code> conventionally start with three slashes (<code>///</code>).</p>
<p>To render the documentation lines, a simple</p>
<pre><code class="language-console">cargo doc
</code></pre>
<p>will generate the online documentation, corresponding to the downloaded release version.
We will timely upload negotiated versions to <a href="https://docs.rs/releases/search?query=orbtk">Docs.rs</a>.</p>
<p>Back to our structure. To keep the code tight and clear, Rust supports
the concept of <strong>modules</strong>. Like in most other higher programming
languages this allows to subdivide your code into related, condense
function blocks. This resolves to increased clarity and
readability. To put the needed modules or crates into scope, take
advantage of the <strong>use</strong> statement.</p>
<p>Both principles helps quite a bit to keep a lean structure beside a
nice developer experience. <code>Ease of use</code> is one main goal, so we
prepare <code>prelude</code> modules, that will take care to present the most
needed peaces accessible in your code. Using short and pregnant
descriptors should be enough to consume the offered <code>OrbTk</code> modules
and functions in your code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-orbtk_core"><a class="header" href="#workspace-orbtk_core">Workspace orbtk_core</a></h1>
<h2 id="application"><a class="header" href="#application">Application</a></h2>
<p>The <code>application</code> crate provides the base api inside an <code>OrbTk</code> application.
Its elements are consumed via dedicated modules organized in the other sub-crates.</p>
<h3 id="the-contextprovider"><a class="header" href="#the-contextprovider">The ContextProvider</a></h3>
<p>This structure is a temporary solution to share dependencies inside an
<code>OrbTk</code> application. Right now, if the app is started, a new
<code>ContextProvider</code> object is created. The interconnection between
sender and receiver are handled using asynchronous channels with
sender/receiver halves (<code>mpsc</code>).</p>
<ul>
<li>
<p>window_sender
A <code>WindowRequest</code> is used to send the given request to the named window.</p>
</li>
<li>
<p>shell_sender A <code>ShellRequest</code> is used to send the given request to
the application shell. The application shell is aware of the
handled windows. They are differenciated via individual
<code>WindowAdapter</code> objects.</p>
</li>
</ul>
<p>In the given version this module isn’t thread save. It will be
refactored in the next upcoming release.</p>
<h3 id="the-windowadapter"><a class="header" href="#the-windowadapter">The WindowAdapter</a></h3>
<p>Each <code>WindowAdapter</code> handles its unique tree, event pipiline and
shell. They are dynamically stored in the undelying <code>DCES</code> via <strong>ECM</strong>
methods.</p>
<p>The shell will react on UI events. The code for dedicated events are
organized in explicit modules that will trigger their handlers:</p>
<ul>
<li>activation events</li>
<li>clipboard updates</li>
<li>drop events</li>
<li>focus events</li>
<li>key events</li>
<li>mouse events</li>
<li>text input events</li>
<li>window resize events</li>
<li>window scroll events</li>
<li>window system events (like <code>quit</code>)</li>
</ul>
<p>The <code>EventAdapter</code> provides a thread safe way to push events to the
widget tree of a window.</p>
<h3 id="the-overlay-widget"><a class="header" href="#the-overlay-widget">The Overlay widget</a></h3>
<p>The <code>Overlay</code> widget allows the handling of children at the top of the
tree. Thus its children will be presented on top of all other widgets
grouped in the widget-tree.</p>
<h2 id="layout"><a class="header" href="#layout">Layout</a></h2>
<p>A <code>layout</code> is used to dynamically order the children of a
widget. Before we can arrange the components on screen, their sizes,
bounds and constraints have to be <strong>measured</strong>. The ordering process
will result in a parent / child relation (<code>tree</code>), that is represented
and handled in the <strong>ECM</strong>. In a next step, the tree components are
<strong>arranged</strong>. The result is rendered into an output buffer. Last not
least the updated areas are signaled to the output screen.</p>
<p>To measure components, the code will provide suitable defaults for
each property as well as a <code>desired_size</code>. The <code>desired_size</code> will
resolve the <strong>height</strong> and <strong>width</strong> property of the child element.
This values can either be overwritten with an <strong>explicit</strong> component
property inside your rust code, or while referencing to definitions
using a <strong>style</strong> property. Please take into account, that a given
<strong>style</strong> definition will take precedence over all explicitly defined
property elements inside the code. OrbTk will not respect a mixture of
both declarations.</p>
<h3 id="the-absolute-placement"><a class="header" href="#the-absolute-placement">The absolute placement</a></h3>
<p>Only components with a <strong>visibility property</strong> that is labeled with a
<code>Collapsed</code> or <code>Visible</code> option will be taken into account, when
calculating bounds and constraints of a child. The resulting bounds are
points, with absolute x and y positions on the screen (<code>floating point values</code>).</p>
<p>New rendering of the child will only occur, if any of its properties is
marked <code>dirty</code>.</p>
<h3 id="the-fixed-size"><a class="header" href="#the-fixed-size">The fixed size</a></h3>
<p>A <strong>fixed sized</strong> layout is defined by fixed bounds for its
child. Think of images that have to be rendered with a given size, or
a minimum size of a text box.</p>
<h3 id="grid-layout"><a class="header" href="#grid-layout">Grid layout</a></h3>
<p>The <strong>grid layout</strong> is a specialized case of the default alignment
layout. If you declare <strong>rows</strong> and <strong>columns</strong>, the child blocks are
calculated suming up each individual block bounds inside the
corresponding row or column.</p>
<p>You may stretch the blocks to the choosen dimension (<strong>horizontal</strong>
vs. <strong>vertical</strong>). As a result, if you resize the window of the
running app, that grid element will consume the extra size available
because of your interactive change. Vice versa, the elements will
shrink down until the grid child will reach the defined minimum bound.</p>
<h3 id="padding-layout"><a class="header" href="#padding-layout">Padding layout</a></h3>
<p>Padding may be needed, as a property of a broad range of
components. The measurement cycle will calculate the padding value (a
<strong>floating point</strong> value) as a constraint that is added to the space
requirements of the associated content component. You may think of the
<code>padding</code> as a surrounding with a given thickness, that is placed
arround your content.</p>
<p>The following image visualizes the dependencies.</p>
<p><a href="img/layout_constraints.png"><img src="img/layout_constraints.png" width="480"/></a></p>
<p><span class="caption">Image 2-2: Layout constraints</span></p>
<h3 id="popup-layout"><a class="header" href="#popup-layout">Popup layout</a></h3>
<p>The <strong>popup layout</strong> is a specialized case of the default alignment
layout. A popup is typically needed to render content, that is related
to a given target widget. That includes the position of the popup
itself, as well as its dynamic created content.</p>
<p>You can find a common use case of a popup if you study the OrbTk code
of a <code>list box</code>.  The list box elements are collected in a stack
widget. The <code>stack</code> itself is placed in a <code>popup</code> widget. And the
popup widget is placed right below the text block that offers a
drop-down selection arrow.</p>
<h3 id="stack-layout"><a class="header" href="#stack-layout">Stack layout</a></h3>
<p>The <strong>stack layout</strong> is a specialized case of the default alignment
layout. A stack offers a use case, where you want to place other
widgets in a congruent <code>horizontal</code> or <code>vertical</code> order.  You may
define a <code>spacing</code> property. This given floating point value is used
as a seperator between each stack member.</p>
<h2 id="localization"><a class="header" href="#localization">Localization</a></h2>
<p>Localization is a research task by itself, if you want to resolve all
syntactic rules that are found when writing prose in different
languages.  OrbTk’s localization crate isn’t ready to resolve all this
complexity, but this may improve in further releases.</p>
<p>Starting with the given implementation, <code>localization</code> can offer methods, that
are able to match and replace text strings. The usage of the <code>localization</code> crate is
optional. If you don’t need any multi lingual adaptions inside your widgets, simply
do not include the <code>localization</code> sugar.</p>
<h3 id="the-building-blocks-of-localization"><a class="header" href="#the-building-blocks-of-localization">The building blocks of localization</a></h3>
<p>If you want to enable the users to select and change the desired display
language of the GUI at runtime, the toolkit needs to match up a requested
text strings (the key) that should be presented inside the view and substitute
it with the corresponding translation string (the target value). Dictionaries
are used to organize the keys as word lists.</p>
<p>OrbTk’s <code>localization</code> implementation has choosen to persitently store
the translation strings inside a <a href="https://github.com/ron-rs/ron"><code>RON</code></a> file. When introducing
the new syntax structure used inside a <code>RON</code> filetype, it was one goal
of the authors to easily match rust types to ron types. That is
exactly the development goal from the RON authors:</p>
<p>“RON is a simple readable data serialization format that looks
similar to Rust syntax. It’s designed to support all of Serde’s data
model, so structs, enums, tuples, arrays, generic maps, and primitive
values.”</p>
<p>You can save each supported language in its individual ron file. The language
files need to be distinctable. A natural way to implement this requirement
is the usage of unique <code>language ids</code>. Most *<em>operating systems</em> take advantage
of a <code>locale subsystem</code>, and save the identification of the active language in
the <code>lang</code> enviroment variable. It’s good practice to include the language id in
the corresponding ron file name.</p>
<p>When you include the <code>localization</code> functionality in your OrbTk code, you
should define constants for each supported <code>language id</code>, that will reference the
ron file in question.</p>
<p>When calling the <code>RonLocalization</code> methods addressing the combination of a language
id and the corresponding dictionary you are able to store the result in <code>language</code>
variable. The crate methods will handle all the heavy lifting to substitute the
source values of the text attributes inside the views with their matching translation
strings in the addressed dictionary.</p>
<h3 id="the-ron-file-structure"><a class="header" href="#the-ron-file-structure">The ron file structure</a></h3>
<p>In OrbTk, the structure <code>RonLocalizationBuilder</code> is defined to take values for
the following parameters</p>
<ul>
<li>language: a String</li>
<li>dictionaries: a HashMap</li>
</ul>
<p>The ron filename representing a language localization should include the language
identifier to ease its distiction from another.</p>
<p>Dictionaries itself are stored
The dictionary is represended by a key value pair</p>
<p>A class <code>Dictionary</code> will include a <code>map</code> named <strong>words</strong>.
The ron type <code>map</code> is like a type <code>struct</code>, but keys are also values instead of
just beenig identifiers.</p>
<ul>
<li>using a ron file</li>
</ul>
<p>Activation of the <code>localization</code> crate inside your source code boils
down to this short example code.</p>
<pre><code class="language-rust ignore">static LOCALIZATION_ES_ES: &amp;str = include_str!(&quot;../assets/localization/dictionary_es_ES.ron&quot;);
</code></pre>
<p>We do define two language identifiers:</p>
<ul>
<li>_de_de: referencing a ron file with german translation strings</li>
<li>_es_es: referencing a ron file with spanish translation strings</li>
</ul>
<pre><code class="language-rust ignore">    Application::new()
        .localization(es_es)
</code></pre>
<p>When creating the Application block, we do pipe in the localization property.
To keep this example simple, a hardcoded <strong>de_DE</strong> is choosen.
The <a href="https://github.com/redox-os/orbtk/tree/develop/orbtk/examples/showcase.rs"><strong>showcase</strong></a> example inside the orbtk source code
implements a tab widget, that offers a dropdown list, to dynamically change
the active language variant.</p>
<pre><code class="language-rust ignore">    let es_es = RonLocalization::create()
        .language(&quot;es_ES&quot;)
        .dictionary(&quot;es_ES&quot;, LOCALIZATION_ES_ES)
        .build();
    /* disabled german translation file
     * let _de_de = RonLocalization::create()
     *    .language(&quot;de_DE&quot;)
     *    .dictionary(&quot;de_DE&quot;, LOCALIZATION_DE_DE)
     *    .build();
     */
</code></pre>
<p>To compile this example code, go ahead and enter the following comand
in your terminal window:</p>
<pre><code class="language-console">$ cargo run --release orbtk_localization
</code></pre>
<p>Your screen should present an application window showing the translated spanish strings.</p>
<p><a href="img/examples/orbtk_localization.png"><img src="img/examples/orbtk_localization.png" height="150"/></a></p>
<p><span class="caption">Image 2-2: Application window with <strong>spanish</strong> localization strings</span></p>
<p>Sure, this code isn’t elegant nor will it suite the real application
demands.  What it does show is the logic, to bind a ron file (storing
the translations of a given language) to a const. When calling
<code>RonLocalization</code>, the <code>text</code> method will resolve text attributes
inside a view or any rust primitive with the translation text resolved
in the language dictionary.</p>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<p>Every entity that is managed via the provided <strong>ECM</strong> methods (in most cases this will
be widgets) will have associated components. If we are
talking about components inside the toolkit, we name them <code>properties</code>
of a given object.</p>
<h3 id="layout-1"><a class="header" href="#layout-1">Layout</a></h3>
<p>Our aim is a dynamic ordering of objects inside the render
buffer. This ordering needs to respect the specific properties of each
object making up the object tree. All properties declared for the
addressed objects will sum up the constraints that need to be
respected within their layout.</p>
<p>Logical units of properties ease the measurement and assignment
process of the given object tree.</p>
<h4 id="blocks"><a class="header" href="#blocks">Blocks</a></h4>
<p>Inside OrbTk the <code>BlockBuilder</code> method handles a block. A <code>block</code> is a
term that defines an object inside the render surface. A legacy form of
the API was using the idiom <code>row</code> or <code>column</code> to define the position
of a block inside a <code>grid</code> widget. We moved on to use blocks as a
generic term that can be used in all widgets.  Blocks will inherit
default properties:</p>
<ul>
<li>a block size</li>
<li>its minumum size</li>
<li>its maximum size</li>
<li>its current size</li>
</ul>
<p>If we measure a <code>block</code> size, we can choose from an enumeration of valid expressions:</p>
<ul>
<li>Auto: The largest child will be used to measure the block size.</li>
<li>Stretch: The block will be expanded and consume all of the available size.</li>
<li>Size: An explicit floading point value.</li>
</ul>
<h4 id="scrollviewermode"><a class="header" href="#scrollviewermode">ScrollViewerMode</a></h4>
<p>To describe the vertical and horizontal scroll behavior of a widget,
we do make use of the <code>ScrollViewerMode</code>. The ScrollViewerMode will
evaluate a valid enumeration value of the <code>ScrollMode</code>. Per default it
will automatically assign the <strong>Auto</strong> value. That will take care
that the layout logic is able to automatically adjust and manage scroll
movements of associated widget elements (e.g. in ListViews, SelectionViews or TextBoxes).</p>
<p>You may want to handle this scroll movements via your own dedicated
code. Just adapt the mode property <code>horizontal</code> and <code>vertical</code> to your needs and select
<code>ScrollMode::Custom</code>. To completely disable any scrolling logic select
<code>ScrollMode::Disabled</code>.</p>
<h4 id="widget"><a class="header" href="#widget">Widget</a></h4>
<h5 id="focusstate"><a class="header" href="#focusstate">FocusState</a></h5>
<p>To offer natural interactivity with the implemented UI, we should
respect workflow standards. E.g a user is expecting the cursor and the
possibility to change a widget element at the next logical
position. Imagine a form, where the UI offers a layout to enter some
address fields. When you activate such a form, you do expect the
cursor position on the first element of the form. Thus, we need the
concept of a <code>Focus</code> that enable the state logic to preset UI
interaction onto a specified element. The <code>FocusState</code> offers methods
to control the state information of widget elements:</p>
<ul>
<li>Request the focus for an entity.</li>
<li>Remove the focus from an entity.</li>
<li>Reference the current focused entity.</li>
<li>Check the focus state of an entity.</li>
</ul>
<h5 id="keyboardstate"><a class="header" href="#keyboardstate">KeyboardState</a></h5>
<p>The keyboard state tracks which keys are currently pressed. The active
state is stored in a lazy-loaded HashMap.</p>
<p>Beside common key activities, you may need to react on generic
modifier keys (<code>Alt</code>, <code>Ctrl</code>, <code>Hyper</code>, <code>Shift</code>). Helper functions
offer several convenience methods to handle such keyboard events. A
generic method comes in handy, if you don’t care which modifier key is
down (<code>Shift-left</code> or <code>Shift-right</code> =&gt; <code>Shift</code>). The example section
will also tackle the case, where a combined event (<code>Ctrl+S</code>) keyboard
state is handled.</p>
<h2 id="render-objects"><a class="header" href="#render-objects">Render Objects</a></h2>
<h2 id="services"><a class="header" href="#services">Services</a></h2>
<h2 id="system"><a class="header" href="#system">System</a></h2>
<h2 id="theming"><a class="header" href="#theming">Theming</a></h2>
<h2 id="tree"><a class="header" href="#tree">Tree</a></h2>
<h2 id="the-widget-base"><a class="header" href="#the-widget-base">The Widget base</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-orbtk_client"><a class="header" href="#workspace-orbtk_client">Workspace orbtk_client</a></h1>
<p><code>WIP</code>: The OrbTk GUI client modules</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-orbtk_tinyskia"><a class="header" href="#workspace-orbtk_tinyskia">Workspace orbtk_tinyskia</a></h1>
<p><a href="img/orbskia.svg"><img src="img/orbskia.svg" width="720"/></a></p>
<p>Rendering is a key component of the toolkit. Everybody is expecting state
of the art presentation of implemented widgets. User interaction that will
result in layout and entity changes inside the GUI should be updated as
soon as possible. A comfortable user experience is mainly influenced by
fast rendering tasks. New rendering of layouts should only take place, if
constraint changes will need to do so. Entities and their attributes will
only require new rendering if a user interaction changes their state
to be dirty.</p>
<p>Lets summarize the main goals of <code>OrbTk</code> rendering infrastructure:</p>
<ul>
<li>
<p>API encapsulated access to all renderer functions</p>
<p>This design decision is taken to keep freedom for further development of
OrbTk when it comes to support different renderers. We are able to support</p>
<ul>
<li>different versions of a given renderer</li>
<li>support different renderer for different target platforms</li>
</ul>
</li>
<li>
<p>2D rendering</p>
<p>We need a fast and complete implementation of all rendering
functions that are supported in the OrbTk toolkit. The following
summary is a list of <code>tiny-skia</code> provided functions:</p>
<ul>
<li>Pixmaps</li>
<li>Canvas</li>
<li>Path</li>
<li>geometry primitives</li>
<li>Blending modes</li>
<li>Path filling</li>
<li>Anti-aliased Path filling</li>
<li>Path stroking</li>
<li>Path hairline stroking</li>
<li>Anti-aliased Path hairline stroking</li>
<li>Stroke dashing</li>
<li>Gradients (linear and radial)</li>
<li>Pixmaps blending (image on image rendering)</li>
<li>Patterns</li>
<li>Fill rect</li>
<li>Stroke rect</li>
<li>Rectangular clipping</li>
<li>Clipping</li>
<li>Anti-aliased clipping</li>
<li>Analytical anti-aliased Path filling</li>
<li>Dithering</li>
<li>Blending modes</li>
</ul>
</li>
</ul>
<p>We are looking forward to a Rust native ecosystem that handles <code>text rendering</code>. This is a complex task and by the time of writing a
complete library addressing this issue isn’t available.
The Rust community has developed building blocks, like</p>
<ul>
<li>Font parser: ttf-parser.</li>
<li>Text shaper: rustybuzz or all-sorts.</li>
<li>Font database: fontdb (supporting a font fallback mechanism).</li>
</ul>
<p>The missing peace, beside the glue code to use the components inside
orbtk_tinyskia is a high-quality <code>glyph rasterization library</code>. Preferably it will offer a <code>FreeType</code> level of
quality. <code>ab_glyph_rasterizer</code> or <code>fontdue</code> might evolve to fill this
gap.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-orbtk_widgets"><a class="header" href="#workspace-orbtk_widgets">Workspace orbtk_widgets</a></h1>
<p>As a UI developer consuming OrbTk, you most probably will get in
touch with the <code>widget</code> sub-crate. If you get comfortable with the
terminology of <code>views</code> and their <code>states</code>, it’s quite easy to
implement even complex structures. The GUI components are declarative
and you will code them inside the <code>view</code> blocks. All callbacks that
will handle the functional processing are coded inside the <code>state</code>
blocks. User input (e.g. mouse events, keyboard input) as well as
event handler generated feedback is handled and processed from methods
of the associated <code>state</code> blocks.</p>
<p>The <code>behavior modules</code> are separated to handle specialized cases. If
an event is emitted that belongs to a behavior class, the associated
action is handled by a behavior method. In particular you will
recognize modules for the following behaviors:</p>
<ul>
<li>focus</li>
<li>mouse</li>
<li>selection</li>
<li>text</li>
</ul>
<h2 id="views"><a class="header" href="#views">Views</a></h2>
<p>When you create a <code>view</code> block inside an OrbTk application, it is
required to insert definitions that declare what elements are going to
be present inside the user interface.</p>
<h3 id="what-is-a-view"><a class="header" href="#what-is-a-view">What is a View</a></h3>
<p>If you take the Rust code that makes a <code>view</code> in a structural way, it
will answer to the following questions:</p>
<ul>
<li>Which entities are used?</li>
<li>What is the entities tree formed?</li>
<li>What attributes are coupled with the given entity?</li>
<li>What handlers should take care when a given event is emitted?</li>
</ul>
<h3 id="what-is-the-code-structure-of-a-view"><a class="header" href="#what-is-the-code-structure-of-a-view">What is the code structure of a View</a></h3>
<p>First, the inside the source code that takes your <code>view</code> needs to call
the <code>widget!</code> macro. This macro automatically implements the <code>Widget</code>
trait. When instantiated, it will inherit all default properties from
a base widget, which gets you started with consistent preset values.</p>
<p>The syntax of this macro call will require you to select</p>
<ul>
<li>the desired <code>view-name</code> (e.g: “NavigationView”)</li>
<li>optional: the name of the associated <code>state-structure</code> (e.g:
“<NavigationState>”)</li>
</ul>
<p>If you like to assign property names inside the view, go ahead and
introduce an extensible list of the property-variables. Each variable
will take a name and define its associated type.</p>
<p>In a next step you enhance the <code>Template</code> trait with an implementation
of your new widget. You are required to code a function called
<code>template</code>.  The syntax of this function will take the following
arguments</p>
<ul>
<li><code>self</code>, the implementation of your view-name</li>
<li>the <code>Id</code> of the entity</li>
<li>the <code>Context</code>, as a mutual reference to the BuildContext</li>
</ul>
<p>All the widget structures you are going to use inside of <code>template</code>
will be coded as child’s of <code>self</code>.</p>
<h2 id="states"><a class="header" href="#states">States</a></h2>
<p>When you create a <code>state</code> block inside an OrbTk application, it is
required to define the structures you want to work on in the <code>State</code>
implementation.</p>
<h3 id="what-is-a-state"><a class="header" href="#what-is-a-state">What is a State</a></h3>
<p>The Rust code that makes a <code>state</code> is associated to the <code>view</code> block
of your widget. Go and ask yourself:</p>
<ul>
<li>What actions should be processed on a given event?</li>
<li>How should we handle user input?</li>
<li>What happens if an entity attribute is changed and gets dirty?</li>
</ul>
<p>From a procedural point of view, states will provide methods that are
processed depending of the event status inside the a widget.</p>
<pre class="mermaid">graph TD;
	State--&gt;init;
	State--&gt;update;
	State--&gt;cleanup;
	update--&gt;message;
	message--&gt;layout;
	layout--&gt;update_post_layout;

</pre>
<p><span class="caption">Workflow 1-1: State handling methods</span></p>
<h3 id="what-is-the-structure-of-a-state"><a class="header" href="#what-is-the-structure-of-a-state">What is the structure of a State</a></h3>
<p>First, inside the source code that takes your <code>state</code>, you will go and
declare its structure name. This name corresponds to the parameter
value you chose inside the <code>widget!</code> macro call of your widgets
view (e.g “NavigationState”).</p>
<p>In a next step you enhance the <code>State</code> trait with an implementation of
your state structure. Most probable, you create and adapt the
following functions:</p>
<h4 id="the-cleanup-function"><a class="header" href="#the-cleanup-function">The <code>cleanup</code> function</a></h4>
<p>This function is called as a destructor, when a widget is removed or
your application terminates.</p>
<h4 id="the-init-function"><a class="header" href="#the-init-function">The <code>init</code> function</a></h4>
<p>This function is called to initialize the widget state. You can preset
attributes <strong>before</strong> the view is activated and presented to the user.</p>
<h4 id="the-message-function"><a class="header" href="#the-message-function">The <code>message</code> function</a></h4>
<p>The <code>message subsystem</code> is offering methods to chain events, that can
be interchanged and accessed from any defined <code>state</code>. You will code a
<code>message</code> function to take advantage of this functionality.</p>
<p>The syntax of this function will take the following arguments</p>
<ul>
<li><code>self</code>, the implementation of your message function</li>
<li>the mutable <code>messages</code> variable, referencing the MessageReader</li>
<li>the <code>Context</code>, as a mutual reference to the BuildContext</li>
</ul>
<p>As already explained, you should define an action enumeration, (e.g
“NavigationAction”), that will code the values that are possible or
desired (e.g “SaveSettings”, “LoadSettings”). Inside the <code>message</code>
function you will loop through the <code>messages</code> and match the action
values you are interested in.</p>
<h4 id="the-update-function"><a class="header" href="#the-update-function">The <code>update</code> function</a></h4>
<p>Whenever the attribute of an entity is changed, OrbTk will render it
dirty. The <code>update</code> function is taking care to react on any triggered
dirty state. You will probably define an <code>Action</code> enumeration that
will name and list all action states you are interested in. Now, if
you match an <code>action</code> in the <code>update</code> function, you can react on this
with all the Rust syntax flexibility.</p>
<h4 id="the-update_post_layout-function"><a class="header" href="#the-update_post_layout-function">The <code>update_post_layout</code> function</a></h4>
<p>OrbTk will run this function <strong>after</strong> the rendering crate has
processed the new layout for your view.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-proc_macros"><a class="header" href="#workspace-proc_macros">Workspace proc_macros</a></h1>
<p><code>WIP</code>: Precedural macros</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-utilities"><a class="header" href="#workspace-utilities">Workspace utilities</a></h1>
<p><code>WIP</code>: OrbTk helper utilities</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-widget-templates"><a class="header" href="#orbtk-widget-templates">OrbTk Widget Templates</a></h1>
<p>Within this sub-section we are going to collect and discuss the
structure of officially provided OrbTk widget <code>Templates</code>. We hope to
cover interesting aspects.</p>
<p>For each template type we do provide a simple reference application,
that will show the features and functionality offered by the
illustrated code. Take the in-lined comments and anchors as a tutorial
on how to take advantage of the presented logic while including the
widget inside your own <code>OrbTk</code> code. If we did well, you can
concentrate on the parts we like to emphasize.</p>
<p>Inside the library, the collection of the annotated example code is filed in
the sub-directory <a href="https://github.com/redox-os/orbtk-book/tree/master/src/listings"><code>listings</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-button"><a class="header" href="#template-button">Template: Button</a></h1>
<p>This subsection will describe an <code>OrbTk</code> UI element called <strong>Button</strong>.</p>
<p>The complete source that demonstrates this template element is presented in <a href="ch03-01-widget-button.html#complete-example-source">Listing 3-1</a>.
After a successful compile run, it should produce the attached screen-shot:</p>
<p><a href="img/examples/orbtk_widget_button.png"><img src="img/examples/orbtk_widget_button.png" width="320"/></a></p>
<p>We did compile for a desktop target (Linux). And if you did clone the
book source to your development system, the corresponding source-code
examples can be found inside the listings sub-directory. To compile it yourself, first change into this directory</p>
<p><em>src/listings/ch03-01-widget-button/listing-03-01</em></p>
<p>Next, use <strong>cargo</strong> to pipeline the compile and linking process. In
the end the target binary will be executed. If you like to get a
rendered output, that annotates the tree structure with respect to
their bounds, please make use of the feature <strong>debug</strong>. This feature
will draw blue boxes around any involved entities.</p>
<pre><code class="language-console">$ cargo run --features debug
</code></pre>
<p><a href="img/examples/orbtk_widget_button_debug.png"><img src="img/examples/orbtk_widget_button_debug.png" width="320"/></a></p>
<h2 id="recap-and-annotation"><a class="header" href="#recap-and-annotation">Recap and annotation</a></h2>
<h3 id="the-anatomy-of-this-template"><a class="header" href="#the-anatomy-of-this-template">The anatomy of this template</a></h3>
<p>Let’s review the relevant parts of the <strong>widget_button</strong> application.</p>
<h3 id="orbtk-code-framing-the-app"><a class="header" href="#orbtk-code-framing-the-app">OrbTk code framing the app</a></h3>
<p>As a first step, We put the needed OrbTk parts into scope.</p>
<pre><code class="language-rust ignore">use orbtk::{
    prelude::*,
    widgets::themes::theme_orbtk::{
        {colors, material_icons_font},
        theme_default_dark,
    },
};
</code></pre>
<p>Next we do declare <code>&quot;str&quot;</code> constants to any involved id’s. This isn’t
strictly necessary, but helps to identify the entities by meaningful names.</p>
<pre><code class="language-rust ignore">pub static ID_BUTTON_CONTAINER: &amp;str = &quot;ButtonContainer&quot;;
pub static ID_BUTTON_CHECK: &amp;str = &quot;ButtonCheck&quot;;
pub static ID_BUTTON_TEXT_BLOCK_HEADER: &amp;str = &quot;ButtonTextBlock Header&quot;;
pub static ID_BUTTON_TEXT_BLOCK_1: &amp;str = &quot;ButtonTextBlock 1&quot;;
pub static ID_BUTTON_TEXT_BLOCK_2: &amp;str = &quot;ButtonTextBlock 2&quot;;
pub static ID_BUTTON_TEXT_BLOCK_3: &amp;str = &quot;ButtonTextBlock 3&quot;;
pub static ID_BUTTON_ICONONLY: &amp;str = &quot;ButtonIcononly&quot;;
pub static ID_BUTTON_TEXTONLY: &amp;str = &quot;ButtonTextonly&quot;;
pub static ID_BUTTON_UNCHECK: &amp;str = &quot;ButtonUncheck&quot;;
pub static ID_BUTTON_STACK: &amp;str = &quot;ButtonStack&quot;;
pub static ID_BUTTON_STYLED: &amp;str = &quot;ButtonStyled&quot;;
pub static ID_BUTTON_VIEW: &amp;str = &quot;ButtonView&quot;;
pub static ID_WINDOW: &amp;str = &quot;button_Window&quot;;
</code></pre>
<p>The <strong>main</strong> function instantiates a new application, that makes use of
the <strong>theme_default_dark</strong> and a re-sizable <strong>Window</strong> as its first
children. For a deeper insight into this UI elements, please consult the
relevant part in this book.</p>
<p>We will now focus our interest on the next part, where we do create a
<strong>ButtonView</strong> as a child inside the <strong>Window</strong> entity.</p>
<pre><code class="language-rust ignore">                .child(
                    ButtonView::new()
                        .id(ID_BUTTON_VIEW)
                        .name(ID_BUTTON_VIEW)
                        .min_width(120.0)
                        .build(ctx),
                )
</code></pre>
<p>The syntax advises the compiler, to implement a <em>ButtonView</em> for the
<strong>Template</strong> trait. The <code>widget!()</code> macro relieves us to type out all
the boiler plate stuff and takes care to create the needed code sugar.</p>
<pre><code class="language-rust ignore">// Represents a button widgets.
widget!(ButtonView {});
</code></pre>
<p>We do use a <a href="https://doc.redox-os.org/orbtk-book/ch03-05-widget_container.html"><strong>Container</strong></a> widget as a first child
inside the template method. It allows us, to place a padding around
the included children. Please refer to its documentation section for
a deeper dive.</p>
<pre><code class="language-rust ignore">            .child(
                Container::new()
                    .id(ID_BUTTON_CONTAINER)
                    .name(ID_BUTTON_CONTAINER)
                    .background(colors::BOMBAY_COLOR)
                    .border_brush(colors::BOMBAY_COLOR)
                    .border_width(2)
                    // padding definition:
                    // as touple clockwise (left, top, right, bottom)
                    .padding((36, 16, 36, 16))
                    .min_width(140.0)
</code></pre>
<p>The container will have a <a href="https://doc.redox-os.org/orbtk-book/ch03-21-widget-stack.html"><strong>Stack</strong></a> child, that we do
consume to attach multiple children in a horizontal
direction. <a href="https://doc.redox-os.org/orbtk-book/ch03-24-widget-textblock.html"><strong>TextBlocks</strong></a> are used to render some
header text above the <strong>Button</strong> children. This is the part of the
code, that we are finally interested in.</p>
<h3 id="orbtk-widget-specific-button"><a class="header" href="#orbtk-widget-specific-button">OrbTk widget specific: <strong>Button</strong></a></h3>
<p>We are going to consume a <strong>button</strong> widget.</p>
<p>As any other template inside the widget tree of <code>OrbTk</code>, the template
is rendered with a preset of sane property values. If you choose not to
explicitly declare any property values inside the view code, the
defaults coded in the template definition will be evaluated.</p>
<p>The following Class-Diagram presents the <strong>button</strong> internal widget tree,
including its default property values:</p>
<pre class="mermaid">classDiagram

Button --o MouseBehavior

MouseBehavior --o Container

Container --o Stack

Stack --o FontIconBlock
Stack --o TextBlock

Button : name[&quot;button&quot;]
Button : style[&quot;button&quot;]
Button : height[36.0]
Button : min_width[64.0]
Button : background[colors-LYNCH_COLOR]
Button : border_radius[4.0]
Button : border_width[0.0]
Button : border_brush[&quot;transparent&quot;]
Button : padding['16.0, 0.0, 16.0, 0.0']
Button : foreground[colors-LINK_WATER_COLOR]
Button : text[]
Button : font_size[orbtk_fonts-FONT_SIZE_12]
Button : font[&quot;Roboto-Regular&quot;]
Button : icon[]
Button : icon_font[&quot;MaterialIcons-Regular&quot;]
Button : icon_size[orbtk_fonts-ICON_FONT_SIZE_12]
Button : icon_brush[colors-LINK_WATER_COLOR]
Button : pressed[false]
Button : spacing[8.0]
Button : container_margin[0]

MouseBehavior : pressed(id)
MouseBehavior : enabled(id)
MouseBehavior : target(id.0)

Container : background(id)
Container : border_radius(id)
Container : border_width(id)
Container : border_brush(id)
Container : padding(id)
Container : opacity(id)
Container : margin(&quot;container_margin&quot;, id)

Stack : orientation(horizontal)
Stack : spacing(id)
Stack : h_align(center)

FontIconBlock : icon(id)
FontIconBlock : icon_brush(id)
FontIconBlock : icon_font(id)
FontIconBlock : icon_size(id)
FontIconBlock : v_align(&quot;center&quot;)

TextBlock : font(id)
TextBlock : font_size(id)
TextBlock : foreground(id)
TextBlock : opacity(id)
TextBlock : text(id)
TextBlock : v_align(&quot;center&quot;)
</pre>
<p><span class="caption">Workflow 3-1: Button tree</span></p>
<p>The first button child hasn’t choosen an icon. Thus the rendered
output will just present the text property.</p>
<pre><code class="language-rust ignore">                            .child(
                                Button::new()
                                    .id(ID_BUTTON_TEXTONLY)
                                    .name(ID_BUTTON_TEXTONLY)
                                    .enabled(false)
                                    .max_width(180.0)
                                    .min_width(90.0)
                                    .text(&quot;Disabled&quot;)
                                    .build(ctx),
                            )
</code></pre>
<p>The button hasn’t declared a “text” property. Thus the rendered output will just present the icon content.</p>
<pre><code class="language-rust ignore">                            .child(
                                Button::new()
                                    .id(ID_BUTTON_CHECK)
                                    .name(ID_BUTTON_CHECK)
                                    .enabled(false)
                                    .icon(material_icons_font::MD_CHECK)
                                    .max_width(180.0)
                                    .min_width(90.0)
                                    .on_enter(|_, _| {
                                        println!(&quot;Enter Button boundries&quot;);
                                    })
                                    .on_leave(|_, _| {
                                        println!(&quot;Leave Button boundries&quot;);
                                    })
                                    .build(ctx),
                            )
</code></pre>
<p>Using a style method. Properties assingned via a theme definition take
precedence over property definitons inside the view code.</p>
<pre><code class="language-rust ignore">                            .child(
                                Button::new()
                                    .id(ID_BUTTON_STYLED)
                                    .name(ID_BUTTON_STYLED)
                                    .style(&quot;button_primary&quot;)
                                    .icon(material_icons_font::MD_360)
                                    .max_width(180.0)
                                    .min_width(90.0)
                                    .pressed(true)
                                    .text(&quot;From style&quot;)
                                    .build(ctx),
                            )
                            .build(ctx),
</code></pre>
<h3 id="complete-example-source"><a class="header" href="#complete-example-source">Complete example source</a></h3>
<p>Find attached the complete source code for our <strong>orbtk_widget_button</strong>
example.</p>
<pre><code class="language-rust ignore"><span class="boring">//!
</span><span class="boring">//! OrbTk-Book: Annotated widget listing
</span><span class="boring">//!
</span><span class="boring">
</span>use orbtk::{
    prelude::*,
    widgets::themes::theme_orbtk::{
        {colors, material_icons_font},
        theme_default_dark,
    },
};

pub static ID_BUTTON_CONTAINER: &amp;str = &quot;ButtonContainer&quot;;
pub static ID_BUTTON_CHECK: &amp;str = &quot;ButtonCheck&quot;;
pub static ID_BUTTON_TEXT_BLOCK_HEADER: &amp;str = &quot;ButtonTextBlock Header&quot;;
pub static ID_BUTTON_TEXT_BLOCK_1: &amp;str = &quot;ButtonTextBlock 1&quot;;
pub static ID_BUTTON_TEXT_BLOCK_2: &amp;str = &quot;ButtonTextBlock 2&quot;;
pub static ID_BUTTON_TEXT_BLOCK_3: &amp;str = &quot;ButtonTextBlock 3&quot;;
pub static ID_BUTTON_ICONONLY: &amp;str = &quot;ButtonIcononly&quot;;
pub static ID_BUTTON_TEXTONLY: &amp;str = &quot;ButtonTextonly&quot;;
pub static ID_BUTTON_UNCHECK: &amp;str = &quot;ButtonUncheck&quot;;
pub static ID_BUTTON_STACK: &amp;str = &quot;ButtonStack&quot;;
pub static ID_BUTTON_STYLED: &amp;str = &quot;ButtonStyled&quot;;
pub static ID_BUTTON_VIEW: &amp;str = &quot;ButtonView&quot;;
pub static ID_WINDOW: &amp;str = &quot;button_Window&quot;;

fn main() {
    // Asure correct initialization, if compiling as a web application
    orbtk::initialize();

    Application::new()
        .theme(
            theme_default_dark()
        )
        .window(|ctx| {
            Window::new()
                .id(ID_WINDOW)
                .name(ID_WINDOW)
                .title(&quot;OrbTk-Book - Widget Button&quot;)
                .position((100.0, 100.0))
                .size(260.0, 400.0)
                .resizable(true)
                .child(
                    ButtonView::new()
                        .id(ID_BUTTON_VIEW)
                        .name(ID_BUTTON_VIEW)
                        .min_width(120.0)
                        .build(ctx),
                )
                .build(ctx)
        })
        .run()
}

// Represents a button widgets.
widget!(ButtonView {});

impl Template for ButtonView {
    fn template(self, _id: Entity, ctx: &amp;mut BuildContext) -&gt; Self {
        self.id(ID_BUTTON_VIEW)
            .name(ID_BUTTON_VIEW)
            .child(
                Container::new()
                    .id(ID_BUTTON_CONTAINER)
                    .name(ID_BUTTON_CONTAINER)
                    .background(colors::BOMBAY_COLOR)
                    .border_brush(colors::BOMBAY_COLOR)
                    .border_width(2)
                    // padding definition:
                    // as touple clockwise (left, top, right, bottom)
                    .padding((36, 16, 36, 16))
                    .min_width(140.0)
                    .child(
                        Stack::new()
                            .id(ID_BUTTON_STACK)
                            .name(ID_BUTTON_STACK)
                            .spacing(8)
                            .child(
                                TextBlock::new()
                                    .id(ID_BUTTON_TEXT_BLOCK_HEADER)
                                    .name(ID_BUTTON_TEXT_BLOCK_HEADER)
                                    .font_size(18)
                                    // generic color names:
                                    // constants from crate `utils` -&gt; colors.txt
                                    .foreground(&quot;black&quot;)
                                    .text(&quot;Available button stylings&quot;)
                                    .build(ctx),
                            )
                            .child(
                                TextBlock::new()
                                    .id(ID_BUTTON_TEXT_BLOCK_1)
                                    .name(ID_BUTTON_TEXT_BLOCK_1)
                                    .font_size(14)
                                    // generic color name : rgb value
                                    .foreground(&quot;#3b434a&quot;)
                                    .text(&quot;Only Text&quot;)
                                    .build(ctx),
                            )
                            .child(
                                Button::new()
                                    .id(ID_BUTTON_TEXTONLY)
                                    .name(ID_BUTTON_TEXTONLY)
                                    .enabled(false)
                                    .max_width(180.0)
                                    .min_width(90.0)
                                    .text(&quot;Disabled&quot;)
                                    .build(ctx),
                            )
                            .child(
                                Button::new()
                                    .id(ID_BUTTON_CHECK)
                                    .name(ID_BUTTON_CHECK)
                                    .text(&quot;Push me!&quot;)
                                    .max_width(180.0)
                                    .min_width(90.0)
                                    .build(ctx),
                            )
                            .child(
                                TextBlock::new()
                                    .id(ID_BUTTON_TEXT_BLOCK_2)
                                    .name(ID_BUTTON_TEXT_BLOCK_2)
                                    .font_size(14)
                                    // theme color names:
                                    // constants from crate `orbtk_widgets`
                                    //  -&gt; src/themes/themes_&lt;theme_name&gt;/colors.rs
                                    .foreground(colors::BRIGHT_GRAY_COLOR)
                                    //.foreground(&quot;#3b434a&quot;)
                                    .text(&quot;Only Icon&quot;)
                                    .build(ctx),
                            )
                            .child(
                                Button::new()
                                    .id(ID_BUTTON_CHECK)
                                    .name(ID_BUTTON_CHECK)
                                    .enabled(false)
                                    .icon(material_icons_font::MD_CHECK)
                                    .max_width(180.0)
                                    .min_width(90.0)
                                    .on_enter(|_, _| {
                                        println!(&quot;Enter Button boundries&quot;);
                                    })
                                    .on_leave(|_, _| {
                                        println!(&quot;Leave Button boundries&quot;);
                                    })
                                    .build(ctx),
                            )
                            .child(
                                Button::new()
                                    .id(ID_BUTTON_ICONONLY)
                                    .name(ID_BUTTON_ICONONLY)
                                    .style(&quot;button_primary&quot;)
                                    .icon(material_icons_font::MD_360)
                                    .max_width(180.0)
                                    .min_width(90.0)
                                    .pressed(true)
                                    .build(ctx),
                            )
                            .child(
                                TextBlock::new()
                                    .id(ID_BUTTON_TEXT_BLOCK_3)
                                    .name(ID_BUTTON_TEXT_BLOCK_3)
                                    .font_size(14)
                                    // theme color names:
                                    // constants from crate `orbtk_widgets`
                                    //  -&gt; src/themes/themes_&lt;theme_name&gt;/colors.rs
                                    .foreground(colors::BRIGHT_GRAY_COLOR)
                                    .text(&quot;Icon and Text&quot;)
                                    .build(ctx),
                            )
                            .child(
                                Button::new()
                                    .id(ID_BUTTON_CHECK)
                                    .name(ID_BUTTON_CHECK)
                                    .enabled(false)
                                    .icon(material_icons_font::MD_CHECK)
                                    .max_width(180.0)
                                    .min_width(90.0)
                                    .text(&quot;Checked&quot;)
                                    .on_enter(|_, _| {
                                        println!(&quot;Enter Button boundries&quot;);
                                    })
                                    .on_leave(|_, _| {
                                        println!(&quot;Leave Button boundries&quot;);
                                    })
                                    .build(ctx),
                            )
                            .child(
                                Button::new()
                                    .id(ID_BUTTON_STYLED)
                                    .name(ID_BUTTON_STYLED)
                                    .style(&quot;button_primary&quot;)
                                    .icon(material_icons_font::MD_360)
                                    .max_width(180.0)
                                    .min_width(90.0)
                                    .pressed(true)
                                    .text(&quot;From style&quot;)
                                    .build(ctx),
                            )
                            .build(ctx),
                    )
                    .build(ctx),
            )
    }
}

</code></pre>
<p><span class="caption">Listing 3-2: orbtk_widget_button - Available button styles.</span></p>
<h3 id="compiling-and-running-are-separate-steps-1"><a class="header" href="#compiling-and-running-are-separate-steps-1">Compiling and Running Are Separate Steps</a></h3>
<p>The <strong>cargo</strong> compiled <code>orbtk_widget_button</code> binary will be placed in the target subfolder of the project.</p>
<pre><code class="language-console">$ cargo build --release --bin orbtk_widget_button
$ ../target/release/orbtk_widget_button
</code></pre>
<p>On Windows, you need to use <code>backslash</code> as a path delimiter:</p>
<pre><code class="language-powershell">&gt; cargo build --release --bin orbtk_widget_button
&gt; ..\target\release\orbtk_widget_button.exe
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-canvas"><a class="header" href="#template-canvas">Template: Canvas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-checkbox"><a class="header" href="#template-checkbox">Template: CheckBox</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-combobox"><a class="header" href="#template-combobox">Template: ComboBox</a></h1>
<p>The following image visualize the structure elements of a <code>ComboBox</code> widget.</p>
<p><a href="img/Structure_Widget_ComboBox.png"><img src="img/Structure_Widget_ComboBox.png" width="720"/></a></p>
<p><span class="caption">Image 03-04: Structure ComboBox widget</span></p>
<p><code>WIP</code>: Explain the structure</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-container"><a class="header" href="#template-container">Template: Container</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-cursor"><a class="header" href="#template-cursor">Template: Cursor</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-fonticonblock"><a class="header" href="#template-fonticonblock">Template: FontIconBlock</a></h1>
<p>This subsection will describe an <code>OrbTk</code> UI element called <strong>FontIconBlock</strong>.</p>
<p>The complete source that demonstrates this template element is presented in <a href="ch03-07-widget-font-icon-block.html#complete-example-source">Listing 7-1</a>.
After a successful compile run, it should produce a window analog to the attached screen-shot:</p>
<p><a href="img/examples/orbtk_widget_font_icon_block.png"><img src="img/examples/orbtk_widget_font_icon_block.png" width="320"/></a></p>
<p>We did compile for a desktop target (Linux). And if you did clone the
book source to your development system, the corresponding source-code
examples can be found inside the listings sub-directory. To compile it
yourself, first change into this directory</p>
<p><em>src/listings/ch03-07-widget-font-icon-block/listing-07-01</em></p>
<p>Next, use <strong>cargo</strong> to pipeline the compile and linking process. In
the end the target binary will be executed. If you like to get a
rendered output, that annotates the tree structure with respect to
their bounds, please make use of the feature <strong>debug</strong>. This feature
will draw blue boxes around any involved entities.</p>
<pre><code class="language-console">$ cargo run --features debug --bin orbtk_widget_font_icon_block
</code></pre>
<p><a href="img/examples/orbtk_widget_font_icon_block_debug.png"><img src="img/examples/orbtk_widget_font_icon_block_debug.png" width="320"/></a></p>
<h2 id="recap-and-annotation-1"><a class="header" href="#recap-and-annotation-1">Recap and annotation</a></h2>
<h3 id="the-anatomy-of-this-template-1"><a class="header" href="#the-anatomy-of-this-template-1">The anatomy of this template</a></h3>
<p>Let’s review the relevant parts of the <strong>orbtk_widget_font_icon_block</strong> application.</p>
<h3 id="orbtk-code-framing-the-app-1"><a class="header" href="#orbtk-code-framing-the-app-1">OrbTk code framing the app</a></h3>
<p>As a first step, We put the needed OrbTk parts into scope.</p>
<pre><code class="language-rust ignore">use orbtk::{
    prelude::*,
    widgets::themes::theme_orbtk::{
        {colors, material_icons_font},
        theme_default_dark,
    },
};
</code></pre>
<p>Next we do declare <code>&quot;str&quot;</code> constants to any involved id’s. This isn’t
strictly necessary, but helps to identify the entities by meaningful names.</p>
<pre><code class="language-rust ignore">pub static ID_FONT_ICON_BLOCK_CONTAINER: &amp;str = &quot;FontIconBlockContainer&quot;;
pub static ID_FONT_ICON_BLOCK_VIEW: &amp;str = &quot;FontIconBlockView&quot;;
pub static ID_FONT_ICON_BLOCK_STACK: &amp;str = &quot;FontIconBlockStack&quot;;
pub static ID_FONT_ICON_BLOCK_TEXT_BLOCK_HEADER: &amp;str = &quot;FontIconBlockTextBlockHeader&quot;;
pub static ID_FONT_ICON_BLOCK_STYLED: &amp;str = &quot;FontIconBlockStyled&quot;;
pub static ID_WINDOW: &amp;str = &quot;FontIconBlock_Window&quot;;
</code></pre>
<p>The <strong>main</strong> function instantiates a new application, that makes use of
the <strong>theme_default_dark</strong> and a re-sizable <strong>Window</strong> as its first
children. For a deeper insight into this UI elements, please consult the
relevant part in this book.</p>
<p>We will now focus our interest on the next part, where we do create a
<strong>FontIconBlockView</strong> as a child inside the <strong>Window</strong> entity.</p>
<pre><code class="language-rust ignore">                .child(
                    FontIconBlockView::new()
                        .id(ID_FONT_ICON_BLOCK_VIEW)
                        .name(ID_FONT_ICON_BLOCK_VIEW)
                        .min_width(120.0)
                        .build(ctx),
                )
</code></pre>
<p>The syntax advises the compiler, to implement a <em>FontIconBlockView</em> for the
<strong>Template</strong> trait. The <code>widget!()</code> macro relieves us to type out all
the boiler plate stuff and takes care to create the needed code sugar.</p>
<pre><code class="language-rust ignore">// Represents a FontIconBlock widgets.
widget!(FontIconBlockView {});
</code></pre>
<p>We do use a <a href="https://doc.redox-os.org/orbtk-book/ch03-05-widget-container.html"><strong>Container</strong></a> widget as a first child
inside the template method. It allows us, to place a padding around
the included children. Please refer to its documentation section for
a deeper dive.</p>
<pre><code class="language-rust ignore">            .child(
                Container::new()
                    .id(ID_FONT_ICON_BLOCK_CONTAINER)
                    .name(ID_FONT_ICON_BLOCK_CONTAINER)
                    //.background(colors::BOMBAY_COLOR)
                    .background(&quot;lightgray&quot;)
                    .border_brush(colors::BOMBAY_COLOR)
                    .border_width(2)
                    // padding definition:
                    // as touple clockwise (left, top, right, bottom)
                    .padding((36, 16, 36, 16))
                    .min_width(140.0)
</code></pre>
<p>The container will have a <a href="https://doc.redox-os.org/orbtk-book/ch03-21-widget-stack.html"><strong>Stack</strong></a> child, that we do
consume to attach multiple children in a vertical
direction. A <a href="https://doc.redox-os.org/orbtk-book/ch03-24-widget-textblock.html"><strong>TextBlock</strong></a> is used to render a
header text above the <strong>FontIconBlock</strong> child. This is the part of the
code, that we are finally interested in.</p>
<h3 id="orbtk-widget-specific-fonticonblock"><a class="header" href="#orbtk-widget-specific-fonticonblock">OrbTk widget specific: <strong>FontIconBlock</strong></a></h3>
<p>We are going to consume a <strong>font_icon_block</strong> widget.</p>
<p>As any other template inside the widget tree of <code>OrbTk</code>, the template
is rendered with a preset of sane property values. If you choose not to
explicitly declare any property values inside the view code, the
defaults coded in the template definition will be evaluated.</p>
<p>The following Class-Diagram presents the <strong>font_icon_block</strong> internal widget tree,
including its default property values:</p>
<pre class="mermaid">classDiagram

Parent --o FontIconBlock

FontIconBlock

FontIconBlock : style(&quot;font-icon-block&quot;)
FontIconBlock : icon(&quot;&quot;)
FontIconBlock : icon_brush(colors-&gt;LINK_WATER_COLOR)
FontIconBlock : icon_font(&quot;MaterialIcons-Regular&quot;)
FontIconBlock : icon_size(orbtk_fonts-&gt;Icon_FONT_SIZE_12)

</pre>
<p><span class="caption">Workflow 7-1: FontIconBlock tree</span></p>
<p>If you uncomment the “.style()” property, all explicitly defined
properties inside the view are rendered useless. The properties
assingned via a theme definition take precedence over property
definitons inside the view code.</p>
<pre><code class="language-rust ignore">                            .child(
                                FontIconBlock::new()
                                    .id(ID_FONT_ICON_BLOCK_STYLED)
                                    .name(ID_FONT_ICON_BLOCK_STYLED)
                                    //.style(&quot;font-icon-block&quot;)
                                    .h_align(&quot;center&quot;)
                                    .icon(material_icons_font::MD_360)
                                    .icon_brush(&quot;repeating-linear-gradient(0.25turn, rgba(255, 255, 0, 0.6), dodgerblue, deepskyblue)&quot;)
                                    .icon_font(&quot;MaterialIcons-Regular&quot;)
                                    .icon_size(128.0)
                                    .build(ctx),
                            )
                            .build(ctx),
</code></pre>
<h3 id="complete-example-source-1"><a class="header" href="#complete-example-source-1">Complete example source</a></h3>
<p>Find attached the complete source code for our <strong>orbtk_widget_button</strong>
example.</p>
<pre><code class="language-rust ignore">use orbtk::{
    prelude::*,
    widgets::themes::theme_orbtk::{
        {colors, material_icons_font},
        theme_default_dark,
    },
};

pub static ID_FONT_ICON_BLOCK_CONTAINER: &amp;str = &quot;FontIconBlockContainer&quot;;
pub static ID_FONT_ICON_BLOCK_VIEW: &amp;str = &quot;FontIconBlockView&quot;;
pub static ID_FONT_ICON_BLOCK_STACK: &amp;str = &quot;FontIconBlockStack&quot;;
pub static ID_FONT_ICON_BLOCK_TEXT_BLOCK_HEADER: &amp;str = &quot;FontIconBlockTextBlockHeader&quot;;
pub static ID_FONT_ICON_BLOCK_STYLED: &amp;str = &quot;FontIconBlockStyled&quot;;
pub static ID_WINDOW: &amp;str = &quot;FontIconBlock_Window&quot;;

fn main() {
    // Asure correct initialization, if compiling as a web application
    orbtk::initialize();

    Application::new()
        .theme(
            theme_default_dark()
        )
        .window(|ctx| {
            Window::new()
                .id(ID_WINDOW)
                .name(ID_WINDOW)
                .title(&quot;OrbTk-Book - Widget FontIconBlock&quot;)
                .position((100.0, 100.0))
                .size(290.0, 200.0)
                .resizable(true)
                .child(
                    FontIconBlockView::new()
                        .id(ID_FONT_ICON_BLOCK_VIEW)
                        .name(ID_FONT_ICON_BLOCK_VIEW)
                        .min_width(120.0)
                        .build(ctx),
                )
                .build(ctx)
        })
        .run()
}

// Represents a FontIconBlock widgets.
widget!(FontIconBlockView {});

impl Template for FontIconBlockView {
    fn template(self, _id: Entity, ctx: &amp;mut BuildContext) -&gt; Self {
        self.id(ID_FONT_ICON_BLOCK_VIEW)
            .name(ID_FONT_ICON_BLOCK_VIEW)
            .child(
                Container::new()
                    .id(ID_FONT_ICON_BLOCK_CONTAINER)
                    .name(ID_FONT_ICON_BLOCK_CONTAINER)
                    //.background(colors::BOMBAY_COLOR)
                    .background(&quot;lightgray&quot;)
                    .border_brush(colors::BOMBAY_COLOR)
                    .border_width(2)
                    // padding definition:
                    // as touple clockwise (left, top, right, bottom)
                    .padding((36, 16, 36, 16))
                    .min_width(140.0)
                    .child(
                        Stack::new()
                            .id(ID_FONT_ICON_BLOCK_STACK)
                            .name(ID_FONT_ICON_BLOCK_STACK)
                            .spacing(8)
                            .child(
                                TextBlock::new()
                                    .id(ID_FONT_ICON_BLOCK_TEXT_BLOCK_HEADER)
                                    .name(ID_FONT_ICON_BLOCK_TEXT_BLOCK_HEADER)
                                    .font_size(18)
                                    // generic color names:
                                    // constants from crate `utils` -&gt; colors.txt
                                    .foreground(&quot;black&quot;)
                                    .text(&quot;Font icon block&quot;)
                                    .build(ctx),
                            )
                            .child(
                                FontIconBlock::new()
                                    .id(ID_FONT_ICON_BLOCK_STYLED)
                                    .name(ID_FONT_ICON_BLOCK_STYLED)
                                    //.style(&quot;font-icon-block&quot;)
                                    .h_align(&quot;center&quot;)
                                    .icon(material_icons_font::MD_360)
                                    .icon_brush(&quot;repeating-linear-gradient(0.25turn, rgba(255, 255, 0, 0.6), dodgerblue, deepskyblue)&quot;)
                                    .icon_font(&quot;MaterialIcons-Regular&quot;)
                                    .icon_size(128.0)
                                    .build(ctx),
                            )
                            .build(ctx),
                    )
                    .build(ctx),
            )
    }
}

</code></pre>
<p><span class="caption">Listing 7-2: orbtk_widget_button - Available button styles.</span></p>
<h3 id="compiling-and-running-are-separate-steps-2"><a class="header" href="#compiling-and-running-are-separate-steps-2">Compiling and Running Are Separate Steps</a></h3>
<p>The <strong>cargo</strong> compiled <code>orbtk_widget_font_icon_block</code> binary will be placed in the target subfolder of the project.</p>
<pre><code class="language-console">$ cargo build --release --bin orbtk_widget_font_icon_block
$ ../target/release/orbtk_widget_font_icon_block
</code></pre>
<p>On Windows, you need to use <code>backslash</code> as a path delimiter:</p>
<pre><code class="language-powershell">&gt; cargo build --release --bin orbtk_widget_font_icon_block
&gt; ..\target\release\orbtk_widget_font_icon_block.exe
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-grid"><a class="header" href="#template-grid">Template: Grid</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-image-widget"><a class="header" href="#template-image-widget">Template: Image-widget</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-listview"><a class="header" href="#template-listview">Template: ListView</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-masterdetail"><a class="header" href="#template-masterdetail">Template: MasterDetail</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-numericbox"><a class="header" href="#template-numericbox">Template: NumericBox</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-pager"><a class="header" href="#template-pager">Template: Pager</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-passwordbox"><a class="header" href="#template-passwordbox">Template: PasswordBox</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-popup"><a class="header" href="#template-popup">Template: Popup</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-progressbar"><a class="header" href="#template-progressbar">Template: ProgressBar</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-scrollbar"><a class="header" href="#template-scrollbar">Template: ScrollBar</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-scrollindicator"><a class="header" href="#template-scrollindicator">Template: ScrollIndicator</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-scrollviewer"><a class="header" href="#template-scrollviewer">Template: ScrollViewer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-slider"><a class="header" href="#template-slider">Template: Slider</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-stack"><a class="header" href="#template-stack">Template: Stack</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-switch"><a class="header" href="#template-switch">Template: Switch</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-tabwidget"><a class="header" href="#template-tabwidget">Template: TabWidget</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-textblock"><a class="header" href="#template-textblock">Template: TextBlock</a></h1>
<p>The following image visualize the structure elements of a <code>TextBlock</code> widget.</p>
<p><a href="img/Structure_Widget_TextForm.png"><img src="img/Structure_Widget_TextForm.png" width="480"/></a></p>
<p><span class="caption">Image 03-24: Structure TextForm widget</span></p>
<p><code>WIP</code>: Explain the structure</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-textbox"><a class="header" href="#template-textbox">Template: TextBox</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-togglebutton"><a class="header" href="#template-togglebutton">Template: Togglebutton</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-window"><a class="header" href="#template-window">Template: Window</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-example-applications"><a class="header" href="#orbtk-example-applications">OrbTk Example Applications</a></h1>
<p>This section provides <code>OrbTk</code> example apps. We hope to cover
interesting aspects of the toolkit.</p>
<p>Take them as a tutorial, all listings are created as a reference. They
have in mind to serve as an introduction to a specific topic. As
educational content, this apps are marked with in-lined comments and
anchors. If we did well, you can concentrate on the parts we like
to emphasize.</p>
<p>Inside the library, you will find the collection of example code in
the subdirectory <em>examples</em> in crate <a href="https://github.com/redox-os/orbtk/tree/develop/orbtk/examples"><code>orbtk</code></a>.</p>
<p>The <code>showcase</code> example serves a special purpose. It groups the
available widgets of the <code>orbtk_widgets</code> crate. Thus it will present a
collection of all available library templates, that you might consume
and extend in your own real world applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-orbtk-1"><a class="header" href="#hello-orbtk-1">Hello OrbTk!</a></h1>
<p>We already introduced the source in <a href="https://doc.redox-os.org/orbtk-book/ch01-02-hello-orbtk.html#pdate-cargotoml">Chapter 01</a>.
For the sake of completeness, and since its a habit to begin with here we go.
Your first first experience with an <code>OrbTk</code> app:</p>
<h2 id="the-project-root"><a class="header" href="#the-project-root">The project root</a></h2>
<p>Change to your project root directory. If you didn’t already create
the app in the first place, go ahead and type the following in your
console:</p>
<pre><code class="language-console">$ cd ~/orbtk-book/examples
</code></pre>
<h2 id="create-the-source-code"><a class="header" href="#create-the-source-code">Create the source code</a></h2>
<p>Next we will use cargo to create the app. All boilerplate tasks are
handled using cargo’s inherited template handling.</p>
<pre><code class="language-console">$ cargo new orbtk_hello
$ cd orbtk_hello
</code></pre>
<p>The first command, <code>cargo new</code>, takes the name of the project
(“<code>orbtk_hello</code>”) as the first argument. The second command changes to
the new project’s directory.</p>
<p>Look at the generated <em>Cargo.toml</em> file:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;orbtk_hello_example&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p><span class="caption">Listing 1-1: Default metadata “orbtk_hello”</span></p>
<p>With <code>cargo new</code>, a default project structure is created. Maybe the
author information is already exchanged if <em>Cargo</em> could obtain a definition
from your environment. <em>Cargo</em> also generated source code for a “Hello, world!”
program. Let’s Check out the corresponding <em>src/main.rs</em> file:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 1-2: Default source file “main.rs”</span></p>
<p>No need to compile that stage with <code>cargo run</code>, since we are going to
exchange the project metadata, as well as the orbtk source code right
away.</p>
<h3 id="update-cargotoml-1"><a class="header" href="#update-cargotoml-1">Update Cargo.toml</a></h3>
<p>First reopen the <em>Cargo.toml</em> file and enter the Code in Listing 1-1 into <em>Cargo.toml</em></p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml ignore">[package]
name = &quot;orbtk_hello&quot;
version = &quot;0.3.1-alpha4&quot;
authors = [
	&quot;Florian Blasius &lt;flovanpt@posteo.de&gt;&quot;,
	&quot;Ralf Zerres &lt;ralf.zerres.de@gmail.com&gt;&quot;,
]
description = &quot;The Orbital Widget Toolkit - Training project&quot;
documentation = &quot;https://docs.rs/orbtk&quot;
repository = &quot;https://github.com/redox-os/orbtk&quot;
readme = &quot;README.md&quot;
license = &quot;MIT&quot;
keywords = [
	&quot;orbital&quot;,
	&quot;widget&quot;,
	&quot;ui&quot;,
]
edition = &quot;2018&quot;

[profile.dev]
opt-level = 1

[dependencies]
orbtk = { git = &quot;https://github.com/redox-os/orbtk.git&quot;, branch = &quot;develop&quot; }
#orbtk = { path = &quot;../../../orbtk&quot;, branch=&quot;next&quot; }

[[bin]]
name = &quot;orbtk_hello&quot;
path = &quot;src/main.rs&quot;
</code></pre>
<p><span class="caption">Listing 1-1: Project metadata “orbtk_hello”</span></p>
<p>You may wonder, why the <em>name</em> property inside the <em>Cargo.toml</em> is
formatted like <code>hello_orbtk</code>.</p>
<pre><code class="language-toml ignore">name = &quot;orbtk_hello&quot;
</code></pre>
<p>It is a good habit to follow rusts
naming convention, that encourages you to use <a href="https://rust-lang.github.io/api-guidelines/naming.html">snake_case</a>
naming. While expanding the <em>OrbTk</em> example sources, we will keep
the grouping prefix <code>orbtk</code>. That way we end up to call our first target
binary <code>orbtk_hello</code>.</p>
<h3 id="update-mainrs-1"><a class="header" href="#update-mainrs-1">Update main.rs</a></h3>
<p>All of the <em>OrbTk</em> specific code that is needed to build our first
example “Hello OrbTk!” is shown in Listing 1-2. It goes to
<em>src/main.rs</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use orbtk::prelude::*;

fn main() {
    // use this only if you want to run it as web application.
    orbtk::initialize();

    Application::new()
        .window(|ctx| {
            Window::new()
                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
                .position((100.0, 100.0))
                .size(420.0, 140.0)
                .child(
                    TextBlock::new()
                        .font_size(28)
                        .h_align(&quot;center&quot;)
                        .text(&quot;Hey OrbTk!&quot;)
                        .v_align(&quot;center&quot;)
                        .build(ctx)
                )
                .build(ctx)
        })
        .run();
}
</code></pre>
<p><span class="caption">Listing 1-2: Code that creates a Window and
prints “Hey OrbTk!”</span></p>
<p>Save the file and go back to your terminal window. Enter the following
commands to compile and run the file:</p>
<pre><code class="language-console">$ cargo run --release --example orbtk_hello
</code></pre>
<p>Regardless of your operating system, a window should be placed on the screen
that prints the string <code>Hey OrbTk!</code> in its center.</p>
<p><a href="img/examples/orbtk_hello.png"><img src="img/examples/orbtk_hello.png" height="150"/></a></p>
<p><span class="caption">Image 1-2: Application window and <code>Hey OrbTk</code></span></p>
<p>If something is preventing to position the window, refer back to the</p>
<p><a href="https://doc.redox-os.org/orbtk-book/ch01-01-installation.html#troubleshooting">“Troubleshooting”</a> part of the
Installation section for ways to get help.</p>
<p>If you can see the rendered output of your <code>Hey OrbTk!</code> app on screen,
congratulations! You’ve written your first OrbTk application.
That makes you an OrbTk programmer — welcome!</p>
<h2 id="recap-and-annotation-2"><a class="header" href="#recap-and-annotation-2">Recap and annotation</a></h2>
<h3 id="the-anatomy-of-an-orbtk-application"><a class="header" href="#the-anatomy-of-an-orbtk-application">The anatomy of an OrbTk application</a></h3>
<p>Let’s review in detail what just happened in your “Hey OrbTk!” application.
Here’s the first piece of the puzzle:</p>
<pre><code class="language-rust ignore">use orbtk::prelude::*;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<p>The first line is introducing a <em>use</em> declaration. A <em>use</em> declaration is used
to shorten the path required to refer to rust module items. The <em>prelude</em> is a
convenient way to a list of things, that rust will automatically import to you
program. Here, we bind the path <em>orbtk::prelude</em>. All default items defined in
this path (referenced with <em>::</em>) are now accessible in your source using their
shorthand name. No need to type in their common prefix (<em>orbtk::prelude::</em>)</p>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span>fn main() {
<span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<p>the third line define a function in Rust. The <code>main</code> function is special: it is
always the first code that runs in every executable Rust program. The first
line declares a function named <code>main</code> that has no parameters and returns
nothing. If there were parameters, they would go inside the parentheses, <code>()</code>.</p>
<p>Also, note that the function body is wrapped in curly brackets, <code>{}</code>. Rust
requires these around all function bodies. It’s good style to place the opening
curly bracket on the same line as the function declaration, adding one space in
between.</p>
<p>An automatic formatter tool called <code>rustfmt</code> will help you to stick to a
standard style across Rust projects. OrbTk is following this guidance.
<code>rustfmt</code> will format your code in a particular style. Depending on the version
of your rust toolchain, it is probably already installed on your computer!
Check the online documentation for more details.</p>
<p>Inside the <code>main</code> function is the following code:</p>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // use this only if you want to run it as web application.
    orbtk::initialize();
<span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<p>Here are some important details to notice.</p>
<ul>
<li>First, Rust style is to indent with four spaces, not a tab.</li>
<li>Second, the method <code>orbkt::initialize</code> does all the hard work to initialize
the orbtk environment.</li>
</ul>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span>    Application::new()
<span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<ul>
<li>Third, the method <code>Application::new</code> creates a new entity in the entity
component system (DECS). DECS is an OrbTk dependency that will create and
organize all OrbTk entities. If OrbTk methods change attributes to the widget
elements, the corresponding DECS object will store this attributes as
components to the given entity.</li>
</ul>
<p>We’ll discuss OrbTk macros and methods in more detail in Chapter &lt;WIP: chapter&gt;.
For now, you just need to know that using a <code>::new()</code> means that you’re calling
the creation method of a given widget (here: <code>Application</code>).</p>
<p>Let’s explain the next lines:</p>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span>        .window(|ctx| {
            Window::new()
                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
                .position((100.0, 100.0))
                .size(420.0, 140.0)
<span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<p>Inside the <code>Application</code> method, we pipe in further instructions. Please notice
the important details:</p>
<ul>
<li>First, Rust style is to indent with another four spaces, not a tab.</li>
<li>Second, The piping is encoded using a <code>dot</code> followed by a new method name
(here <code>window</code>).</li>
<li>Third, the <code>windows</code> method takes a Rust closure as its argument.</li>
</ul>
<p>If you are not familiar with the concept of
<a href="https://doc.rust-lang.org/rust-by-example/fn/closures.html">closures</a>,
go ahead and consult the Rust book reference for a deep dive. For now,
you just need to know that a closure can be used as a language
shortcut for a function.  When the closure <code>|ctx| {}</code> is executed, the
result will be captured inside a return variable (<code>ctx</code>). The curly
braces define the body, with the code that is executed inside the
closure.</p>
<p>Let’s examine this body code of our closure:</p>
<ul>
<li>First, we call a method to create a new window entity.
(<code>Windows::new</code>).</li>
<li>Second, we define attributes attached to this entity (<code>title</code>,
<code>position</code>, <code>size</code>).</li>
<li>Third, inside the defined windows, we create a new child entity
(<code>child</code>).</li>
</ul>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span>                .child(
                    TextBlock::new()
                        .font_size(28)
                        .h_align(&quot;center&quot;)
                        .text(&quot;Hey OrbTk!&quot;)
                        .v_align(&quot;center&quot;)
                        .build(ctx)
                )
<span class="boring">                .build(ctx)
</span><span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<ul>
<li>Forth, the child method takes arguments. We create a new text block
entity (<code>Textblock::new</code>). The text block is extended with the attributes
(<code>text</code>, <code>h_align</code>, <code>v_align</code>).
The text attribute takes the desired string. Its positioning is
controlled with the attribution of the horizontal and vertical
alignment. By choosing “center”, we do advise the renderer to place
the entity centered within its parent entity, which is the window.</li>
</ul>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span>                .build(ctx)
<span class="boring">        })
</span><span class="boring">        .run();
</span><span class="boring">}
</span></code></pre>
<p>OrbTk is as lazy as possible. We need to call the build method (<code>build(ctx)</code>),
that will instantiate our methods and let the renderer do its work.</p>
<pre><code class="language-rust ignore"><span class="boring">use orbtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // use this only if you want to run it as web application.
</span><span class="boring">    orbtk::initialize();
</span><span class="boring">
</span><span class="boring">    Application::new()
</span><span class="boring">        .window(|ctx| {
</span><span class="boring">            Window::new()
</span><span class="boring">                .title(&quot;OrbTk-Book - Chapter 1.2&quot;)
</span><span class="boring">                .position((100.0, 100.0))
</span><span class="boring">                .size(420.0, 140.0)
</span><span class="boring">                .child(
</span><span class="boring">                    TextBlock::new()
</span><span class="boring">                        .font_size(28)
</span><span class="boring">                        .h_align(&quot;center&quot;)
</span><span class="boring">                        .text(&quot;Hey OrbTk!&quot;)
</span><span class="boring">                        .v_align(&quot;center&quot;)
</span><span class="boring">                        .build(ctx)
</span><span class="boring">                )
</span><span class="boring">                .build(ctx)
</span><span class="boring">        })
</span>        .run();
<span class="boring">}
</span></code></pre>
<p>With the last statement, we finally call the method that will activate the
Application and draw the Widget on our screen (<code>run</code>).</p>
<p>Most lines of Rust code are finalized with a semicolon (<code>;</code>), to indicates that this
expression is finished and the next one is ready to begin.</p>
<h3 id="compiling-and-running-are-separate-steps-3"><a class="header" href="#compiling-and-running-are-separate-steps-3">Compiling and Running Are Separate Steps</a></h3>
<p>Before running an OrbTk application, you must compile its source code. A typical
OrbTk project will generate the executable binary code using cargo and place the
result in the target subfolder of the project.</p>
<p>Profiles may be used to configure compiler options such as optimization levels
and debug settings. By default the <code>dev</code> or <code>test</code> profiles are used. If the
<code>--release</code> flag is given, then the release or bench profiles are used.</p>
<pre><code class="language-console">$ cargo build --release --bin orbtk_hello.rs
$ ../target/release/hello_orbtk
</code></pre>
<p>On Windows, you need to use <code>backslash</code> as a path delimiter:</p>
<pre><code class="language-powershell">&gt; cargo build --release --bin orbtk-hello.rs
&gt; ..\target\release\orbtk_hello.exe
</code></pre>
<p>If you like to get debug feedback you can call the build process like this</p>
<pre><code class="language-console">$ cargo build --features debug --bin hello_orbtk.rs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-example-showcase"><a class="header" href="#orbtk-example-showcase">OrbTk Example Showcase</a></h1>
<p>The <code>showcase</code> example serves a special purpose. It groups the
available widgets of the <code>orbtk_widgets</code> crate.</p>
<p>You will find followin subsections:</p>
<ul>
<li>Button / Text</li>
<li>Items</li>
<li>Layouts</li>
<li>Image</li>
<li>Localization</li>
<li>Navigation</li>
<li>Interactive</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-example-message-handling"><a class="header" href="#orbtk-example-message-handling">OrbTk Example Message-Handling</a></h1>
<p>This is WIP.</p>
<p>Please document the example application msg-handling.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-example-message-handling-1"><a class="header" href="#orbtk-example-message-handling-1">OrbTk Example Message-Handling</a></h1>
<p>This is WIP</p>
<p>Please document the example application popups.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-example-tableview"><a class="header" href="#orbtk-example-tableview">OrbTk Example TableView</a></h1>
<p>This is WIP and DRAFT.</p>
<p>Please cratre the example application tableview.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-appendix"><a class="header" href="#orbtk-appendix">OrbTk Appendix</a></h1>
<p>This is WIP</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-appendix---keywords"><a class="header" href="#orbtk-appendix---keywords">OrbTk Appendix - Keywords</a></h1>
<p>This is WIP</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-appendix---operators"><a class="header" href="#orbtk-appendix---operators">OrbTk Appendix - Operators</a></h1>
<p>This is WIP</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbtk-appendix---derivable-traits"><a class="header" href="#orbtk-appendix---derivable-traits">OrbTk Appendix - Derivable Traits</a></h1>
<p>This is WIP</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-d-translations-of-the-book"><a class="header" href="#appendix-d-translations-of-the-book">Appendix D: Translations of the Book</a></h1>
<p>For resources in languages other than English. This is work in progress; see
<a href="https://github.com/redox-os/orbtk-book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">the Translations label</a> to help or let us know about a new translation!</p>
<ul>
<li><a href="https://github.com/redox-os/orbtk">Deutsch</a></li>
<li><a href="https://github.com/redox-os/orbtk">Français</a></li>
</ul>
<!---
- [Deutsch](https://github.com/redox-os/orbtk/book-de)
- [Français](https://github.com/redox-os/orbtk/book-fr)
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferries.js"></script>
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
